<template>
  <div class="schelling-model">
    <!-- æ·»åŠ ä»‹ç»å¼¹çª— -->
    <el-dialog
      v-model="showIntroDialog"
      title="è°¢æ—æ¨¡å‹ä»‹ç»                 åˆ¶ä½œäººè´¾ä¹¦å‡¡"
      width="60%"
      :show-close="true"
      :close-on-click-modal="true"
    >
      <div class="intro-content">
        <h3>ä»€ä¹ˆæ˜¯è°¢æ—æ¨¡å‹ï¼Ÿ</h3>
        <p>è°¢æ—æ¨¡å‹(Schelling's Model)æ˜¯ç”±è¯ºè´å°”ç»æµå­¦å¥–å¾—ä¸»æ‰˜é©¬æ–¯Â·è°¢æ—(Thomas Schelling)åœ¨1971å¹´æå‡ºçš„ä¸€ä¸ªç»å…¸æ¨¡å‹ï¼Œç”¨äºè§£é‡Šç§æ—éš”ç¦»ç­‰ç¤¾ä¼šç°è±¡å¦‚ä½•ä»ä¸ªä½“è¡Œä¸ºä¸­è‡ªå‘äº§ç”Ÿã€‚</p>
        
        <h3>æ¨¡å‹åŸç†</h3>
        <p>æ¨¡å‹åŸºäºä»¥ä¸‹ç®€å•è§„åˆ™ï¼š</p>
        <ul>
          <li>åœ¨ä¸€ä¸ªç½‘æ ¼ä¸­ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„ä¸ªä½“å’Œä¸€äº›ç©ºç½®å•å…ƒæ ¼</li>
          <li>æ¯ä¸ªä¸ªä½“éƒ½å¸Œæœ›å‘¨å›´è‡³å°‘æœ‰ä¸€å®šæ¯”ä¾‹çš„é‚»å±…ä¸è‡ªå·±ç±»å‹ç›¸åŒ</li>
          <li>å¦‚æœè¿™ä¸ªæ¡ä»¶ä¸æ»¡è¶³ï¼Œä¸ªä½“ä¼šå˜å¾—"ä¸æ»¡æ„"å¹¶å¯»æ±‚ç§»åŠ¨åˆ°ä¸€ä¸ªç©ºç½®å•å…ƒæ ¼</li>
          <li>å³ä½¿ä¸ªä½“åªæœ‰è½»å¾®çš„åå¥½(å¦‚å¸Œæœ›30%çš„é‚»å±…ç›¸åŒ)ï¼Œç³»ç»Ÿæœ€ç»ˆä¹Ÿä¼šå‘ˆç°é«˜åº¦éš”ç¦»çŠ¶æ€</li>
        </ul>
        
        <h3>æ¨¡å‹å‚æ•°</h3>
        <ul>
          <li><strong>ç½‘æ ¼å¤§å°</strong>ï¼šæ¨¡æ‹ŸåŒºåŸŸçš„å¤§å°</li>
          <li><strong>æ»¡æ„é˜ˆå€¼</strong>ï¼šä¸ªä½“å¸Œæœ›å‘¨å›´ç›¸åŒç±»å‹é‚»å±…çš„æœ€ä½æ¯”ä¾‹</li>
          <li><strong>ç©ºç½®ç‡</strong>ï¼šç½‘æ ¼ä¸­ç©ºç½®å•å…ƒæ ¼çš„æ¯”ä¾‹</li>
        </ul>
        
        <h3>æ¨¡å‹æ„ä¹‰</h3>
        <p>è°¢æ—æ¨¡å‹å±•ç¤ºäº†ä¸€ä¸ªé‡è¦çš„ç¤¾ä¼šå­¦æ´è§ï¼šå³ä½¿ä¸ªä½“æ²¡æœ‰å¼ºçƒˆçš„æ­§è§†å€¾å‘ï¼Œä»…ä»…åŸºäºå¯¹ç›¸ä¼¼æ€§çš„è½»å¾®åå¥½ï¼Œä¹Ÿå¯èƒ½å¯¼è‡´å®è§‚å±‚é¢ä¸Šçš„ä¸¥é‡éš”ç¦»ã€‚è¿™ä¸€å‘ç°å¯¹ç†è§£åŸå¸‚ç§æ—éš”ç¦»ã€ç¤¾ä¼šåˆ†å±‚ç­‰ç°è±¡å…·æœ‰é‡è¦æ„ä¹‰ã€‚</p>
        
        <div class="intro-footer">
          <el-button type="primary" @click="showIntroDialog = false">å¼€å§‹æ¢ç´¢æ¨¡å‹</el-button>
        </div>
      </div>
    </el-dialog>
    
    <!-- ä»ªè¡¨ç›˜å¼¹çª— -->
    <el-dialog
      v-model="showDashboardDialog"
      title="æ¨¡æ‹Ÿæ•°æ®ä»ªè¡¨ç›˜"
      width="80%"
      :show-close="true"
      :close-on-click-modal="true"
      custom-class="dashboard-dialog"
    >
      <div class="dashboard-content">
        <el-row :gutter="20">
          <!-- éš”ç¦»æŒ‡æ•° - ç¼©å°å®½åº¦ -->
          <el-col :span="6">
            <el-card shadow="never" class="dashboard-card">
              <template #header>
                <div class="dashboard-header">
                  <h3>éš”ç¦»æŒ‡æ•°ä»ªè¡¨</h3>
                </div>
              </template>
              <div ref="gaugeContainer" class="gauge-container"></div>
            </el-card>
          </el-col>
          <!-- æ»¡æ„åº¦åˆ†å¸ƒ - ç¼©å°å®½åº¦ -->
          <el-col :span="6">
            <el-card shadow="never" class="dashboard-card">
              <template #header>
                <div class="dashboard-header">
                  <h3>æ»¡æ„åº¦åˆ†å¸ƒ</h3>
                </div>
              </template>
              <div ref="pieContainer" class="pie-container"></div>
            </el-card>
          </el-col>
          <!-- æ”¶æ•›æ€§åˆ†æ - å¢åŠ å®½åº¦ -->
          <el-col :span="12">
            <el-card shadow="never" class="dashboard-card">
              <template #header>
                <div class="dashboard-header">
                  <h3>æ”¶æ•›æ€§åˆ†æ</h3>
                </div>
              </template>
              <div ref="convergenceContainer" class="convergence-container"></div>
            </el-card>
          </el-col>
        </el-row>
        
        <el-row :gutter="20" style="margin-top: 20px;">
          <el-col :span="24">
            <el-card shadow="never" class="dashboard-card">
              <template #header>
                <div class="dashboard-header">
                  <h3>æ¼”åŒ–è¶‹åŠ¿</h3>
                </div>
              </template>
              <div ref="chartContainer" class="large-chart-container"></div>
            </el-card>
          </el-col>
        </el-row>
      </div>
    </el-dialog>

    <el-card class="main-card">
      <template #header>
        <div class="header">
          <div>
            <h2>è°¢æ—æ¨¡å‹æ¨¡æ‹Ÿ</h2>
            <p>æ¨¡æ‹Ÿç§æ—éš”ç¦»ç°è±¡çš„åŠ¨æ€æ¼”åŒ–è¿‡ç¨‹</p>
          </div>
          <el-button-group>
            <el-button type="primary" @click="initializeGrid">
              <el-icon><Refresh /></el-icon> é‡ç½®
            </el-button>
            <el-button type="success" @click="runSimulation" :disabled="isRunning">
              <el-icon><VideoPlay /></el-icon> {{ isRunning ? 'è¿è¡Œä¸­...' : 'å¼€å§‹' }}
            </el-button>
            <el-button type="warning" @click="stopSimulation">
              <el-icon><VideoPause /></el-icon> æš‚åœ
            </el-button>
            <el-button @click="exportData">
              <el-icon><Download /></el-icon> å¯¼å‡ºæ•°æ®
            </el-button>
            <el-button @click="showIntroDialog = true">
              <el-icon><InfoFilled /></el-icon> æ¨¡å‹ä»‹ç»
            </el-button>
            <!-- æ·»åŠ ä»ªè¡¨ç›˜æŒ‰é’® -->
            <el-button @click="showDashboardDialog = true">
              <el-icon><DataAnalysis /></el-icon> æ•°æ®ä»ªè¡¨ç›˜
            </el-button>
          </el-button-group>
        </div>
      </template>
      
      <el-row :gutter="20">
        <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ - ä»span="4"è°ƒæ•´ä¸ºspan="7" -->
        <el-col :span="7">
          <el-card shadow="never">
            <h3>å‚æ•°è®¾ç½®</h3>
            <el-form label-width="100px" size="small">
              <el-form-item label="ç½‘æ ¼å¤§å°">
                <el-slider v-model="gridSize" :min="10" :max="50" show-input />
              </el-form-item>
              <el-form-item label="æ»¡æ„é˜ˆå€¼">
                <el-slider v-model="threshold" :min="0.1" :max="0.9" :step="0.1" show-input />
              </el-form-item>
              <el-form-item label="ç©ºç½®ç‡">
                <el-slider v-model="emptyRate" :min="0.1" :max="0.5" :step="0.1" show-input />
              </el-form-item>
              <el-form-item label="æ¨¡æ‹Ÿé€Ÿåº¦">
                <el-slider 
                  v-model="simulationSpeed" 
                  :min="1" 
                  :max="10" 
                  :format-tooltip="formatSpeedTooltip"
                  show-input />
              </el-form-item>
            </el-form>
          </el-card>
          
          <el-card shadow="never" style="margin-top: 20px;">
            <h3>ç»Ÿè®¡ä¿¡æ¯</h3>
            <el-descriptions :column="1" border size="small">
              <el-descriptions-item label="è¿­ä»£æ¬¡æ•°">{{ iterations }}</el-descriptions-item>
              <el-descriptions-item label="éš”ç¦»æŒ‡æ•°">{{ segregationIndex }}%</el-descriptions-item>
              <el-descriptions-item label="ä¸æ»¡æ„ä¸ªä½“">{{ unsatisfiedCount }}</el-descriptions-item>
            </el-descriptions>
          </el-card>
        </el-col>
        
        <!-- å³ä¾§ç½‘æ ¼å¯è§†åŒ– - ä»span="20"è°ƒæ•´ä¸ºspan="17" -->
        <el-col :span="15">
          <el-tabs v-model="activeView" class="grid-tabs">
            <el-tab-pane label="ç½‘æ ¼è§†å›¾" name="grid">
              <el-card shadow="never" class="grid-card">
                <template #header>
                  <div class="grid-header">
                    <h3>ç½‘æ ¼å¯è§†åŒ–</h3>
                    <div class="color-legend">
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #f8f9fa;"></div>
                        <span>ç©ºç½®å•å…ƒæ ¼</span>
                      </div>
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #ff7675;"></div>
                        <span>ç±»å‹1 - æ»¡æ„</span>
                      </div>
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #fab1a0;"></div>
                        <span>ç±»å‹1 - ä¸æ»¡æ„</span>
                      </div>
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #74b9ff;"></div>
                        <span>ç±»å‹2 - æ»¡æ„</span>
                      </div>
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #a0d2f3;"></div>
                        <span>ç±»å‹2 - ä¸æ»¡æ„</span>
                      </div>
                    </div>
                  </div>
                </template>
                <!-- ä½¿ç”¨flexå¸ƒå±€è‡ªåŠ¨å¡«å……å¯ç”¨ç©ºé—´ -->
                <div class="grid-flex-container">
                  <div ref="gridContainer" class="grid-container"></div>
                </div>
              </el-card>
            </el-tab-pane>
            <el-tab-pane label="çƒ­åŠ›å›¾" name="heatmap">
              <el-card shadow="never" class="grid-card">
                <template #header>
                  <div class="grid-header">
                    <h3>èšé›†çƒ­åŠ›å›¾</h3>
                    <el-radio-group v-model="heatmapType" size="small" @change="updateHeatmap">
                      <el-radio-button label="type1">ç±»å‹1åˆ†å¸ƒ</el-radio-button>
                      <el-radio-button label="type2">ç±»å‹2åˆ†å¸ƒ</el-radio-button>
                    </el-radio-group>
                  </div>
                </template>
                <!-- ä½¿ç”¨flexå¸ƒå±€è‡ªåŠ¨å¡«å……å¯ç”¨ç©ºé—´ -->
                <div class="grid-flex-container">
                  <div ref="heatmapContainer" class="grid-container"></div>
                </div>
              </el-card>
            </el-tab-pane>
            <!-- æ·»åŠ æ»¡æ„åº¦çƒ­åŠ›å›¾è§†å›¾ -->
            <el-tab-pane label="æ»¡æ„åº¦çƒ­åŠ›å›¾" name="satisfaction">
              <el-card shadow="never" class="grid-card">
                <template #header>
                  <div class="grid-header">
                    <h3>æ»¡æ„åº¦åˆ†å¸ƒçƒ­åŠ›å›¾</h3>
                    <div class="color-legend">
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #f8f9fa;"></div>
                        <span>ç©ºç½®å•å…ƒæ ¼</span>
                      </div>
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #4cd137;"></div>
                        <span>é«˜æ»¡æ„åº¦</span>
                      </div>
                      <div class="legend-item">
                        <div class="color-box" style="background-color: #e84118;"></div>
                        <span>ä½æ»¡æ„åº¦</span>
                      </div>
                    </div>
                  </div>
                </template>
                <div class="grid-flex-container">
                  <div ref="satisfactionContainer" class="grid-container"></div>
                </div>
              </el-card>
            </el-tab-pane>
          </el-tabs>
        </el-col>
      </el-row>
    </el-card>
  </div>
</template>

<script>
import * as d3 from 'd3'
import { Refresh, VideoPlay, VideoPause, Download, InfoFilled, DataAnalysis } from '@element-plus/icons-vue'

export default {
  name: 'SchellingModel',
  components: {
    Refresh,
    VideoPlay,
    VideoPause,
    Download,
    InfoFilled,
    DataAnalysis
  },
  data() {
    return {
      showIntroDialog: true, // è®¾ç½®ä¸ºtrueä»¥åœ¨é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ˜¾ç¤º
      showDashboardDialog: false, // æ·»åŠ ä»ªè¡¨ç›˜å¯¹è¯æ¡†æ§åˆ¶å˜é‡
      gridSize: 20,
      threshold: 0.3,
      emptyRate: 0.2,
      simulationSpeed: 5,
      grid: [],
      iterations: 0,
      segregationIndex: 0,
      unsatisfiedCount: 0,
      isRunning: false,
      intervalId: null,
      historyData: {
        iterations: [],
        segregationIndex: [],
        unsatisfiedCount: []
      },
      chartSvg: null,
      chartScales: null,
      activeView: 'grid',
      heatmapType: 'type1',
      
      // æ·»åŠ æ–°çš„æ•°æ®å±æ€§
      trajectories: [], // å­˜å‚¨ç§»åŠ¨è½¨è¿¹
      lastMovedAgent: null, // æœ€åç§»åŠ¨çš„ä¸ªä½“
      movingAgents: new Set(), // æ­£åœ¨ç§»åŠ¨çš„ä¸ªä½“
      convergenceData: [], // æ”¶æ•›æ€§æ•°æ®
      satisfactionDistribution: { // æ»¡æ„åº¦åˆ†å¸ƒæ•°æ®
        satisfied: { type1: 0, type2: 0 },
        unsatisfied: { type1: 0, type2: 0 }
      },
      currentCellSize: 0 // å­˜å‚¨å½“å‰å•å…ƒæ ¼å°ºå¯¸
    }
  },
  mounted() {
    this.showIntroDialog = true; // ç¡®ä¿å¯¹è¯æ¡†æ˜¾ç¤º
    this.initializeGrid()
    // æ·»åŠ çª—å£å¤§å°å˜åŒ–ç›‘å¬ï¼Œä»¥ä¾¿é‡æ–°æ¸²æŸ“ç½‘æ ¼
    window.addEventListener('resize', this.handleResize)
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize)
  },
  watch: {
    activeView(newVal) {
      if (newVal === 'heatmap') {
        this.$nextTick(() => {
          this.renderHeatmap()
        })
      } else if (newVal === 'grid') {
        this.$nextTick(() => {
          this.renderGrid()
        })
      } else if (newVal === 'satisfaction') {
        this.$nextTick(() => {
          this.renderSatisfactionHeatmap()
        })
      } else if (newVal === 'trajectories') {
        this.$nextTick(() => {
          this.renderTrajectories()
        })
      }
    },
    showDashboardDialog(newVal) {
      if (newVal) {
        this.$nextTick(() => {
          this.renderGauge()
          this.renderPieChart()
          this.renderConvergenceChart()
          this.renderChart()
        })
      }
    }
  },
  methods: {
    handleResize() {
      if (this.activeView === 'grid') {
        this.renderGrid()
      } else if (this.activeView === 'heatmap') {
        this.renderHeatmap()
      } else if (this.activeView === 'satisfaction') {
        this.renderSatisfactionHeatmap()
      } else if (this.activeView === 'trajectories') {
        this.renderTrajectories()
      }
      
      if (this.showDashboardDialog) {
        this.renderChart() // é‡æ–°æ¸²æŸ“æŠ˜çº¿å›¾
        this.renderGauge() // é‡æ–°æ¸²æŸ“ä»ªè¡¨ç›˜
        this.renderPieChart() // é‡æ–°æ¸²æŸ“é¥¼å›¾
        this.renderConvergenceChart() // é‡æ–°æ¸²æŸ“æ”¶æ•›æ€§å›¾
      }
    },
    
    formatSpeedTooltip(val) {
      return `${val}x`
    },
    
    initializeGrid() {
      this.stopSimulation()
      this.iterations = 0
      this.grid = []
      
      // åˆ›å»ºç½‘æ ¼
      for (let i = 0; i < this.gridSize; i++) {
        this.grid[i] = []
        for (let j = 0; j < this.gridSize; j++) {
          const rand = Math.random()
          if (rand < this.emptyRate) {
            this.grid[i][j] = 0 // ç©ºç½®
          } else if (rand < this.emptyRate + (1 - this.emptyRate) / 2) {
            this.grid[i][j] = 1 // ç±»å‹1
          } else {
            this.grid[i][j] = 2 // ç±»å‹2
          }
        }
      }
      
      this.calculateStatistics()
      this.renderGrid()
      
      // å¦‚æœå½“å‰æ˜¯çƒ­åŠ›å›¾è§†å›¾ï¼Œä¹Ÿæ›´æ–°çƒ­åŠ›å›¾
      if (this.activeView === 'heatmap') {
        this.renderHeatmap()
      } else if (this.activeView === 'satisfaction') {
        this.renderSatisfactionHeatmap()
      } else if (this.activeView === 'trajectories') {
        this.renderTrajectories()
      }
      
      // é‡ç½®å†å²æ•°æ®
      this.historyData = {
        iterations: [0],
        segregationIndex: [parseFloat(this.segregationIndex)],
        unsatisfiedCount: [this.unsatisfiedCount]
      }
      
      // é‡ç½®è½¨è¿¹
      this.trajectories = []
      this.lastMovedAgent = null
      this.movingAgents.clear()
      
      // é‡ç½®æ”¶æ•›æ€§æ•°æ®
      this.convergenceData = []
      
      // å¦‚æœä»ªè¡¨ç›˜å¯¹è¯æ¡†æ‰“å¼€ï¼Œæ›´æ–°ä»ªè¡¨ç›˜
      if (this.showDashboardDialog) {
        this.renderChart()
        this.renderGauge()
        this.renderPieChart()
        this.renderConvergenceChart()
      }
    },
    
    runSimulation() {
      this.isRunning = true
      // æ ¹æ®é€Ÿåº¦è°ƒæ•´é—´éš”æ—¶é—´
      const interval = Math.max(50, 500 - (this.simulationSpeed * 45))
      this.intervalId = setInterval(() => {
        const moved = this.simulateOneStep()
        if (!moved) {
          this.stopSimulation()
        }
      }, interval)
    },
    
    stopSimulation() {
      this.isRunning = false
      if (this.intervalId) {
        clearInterval(this.intervalId)
        this.intervalId = null
      }
    },
    
    simulateOneStep() {
      const unsatisfied = []
      const empty = []
      
      // æ‰¾åˆ°ä¸æ»¡æ„çš„ä¸ªä½“å’Œç©ºä½ç½®
      for (let i = 0; i < this.gridSize; i++) {
        for (let j = 0; j < this.gridSize; j++) {
          if (this.grid[i][j] === 0) {
            empty.push([i, j])
          } else if (!this.isSatisfied(i, j)) {
            unsatisfied.push([i, j])
          }
        }
      }
      
      if (unsatisfied.length === 0 || empty.length === 0) {
        return false // æ²¡æœ‰ç§»åŠ¨
      }
      
      // éšæœºé€‰æ‹©ä¸€ä¸ªä¸æ»¡æ„çš„ä¸ªä½“ç§»åŠ¨åˆ°ç©ºä½ç½®
      const agentIndex = Math.floor(Math.random() * unsatisfied.length)
      const emptyIndex = Math.floor(Math.random() * empty.length)
      
      const [agentX, agentY] = unsatisfied[agentIndex]
      const [emptyX, emptyY] = empty[emptyIndex]
      
      // è®°å½•ç§»åŠ¨è½¨è¿¹
      this.trajectories.push({
        from: { x: agentX, y: agentY },
        to: { x: emptyX, y: emptyY },
        type: this.grid[agentX][agentY],
        iteration: this.iterations
      })
      
      // è®°å½•æœ€åç§»åŠ¨çš„ä¸ªä½“
      this.lastMovedAgent = { x: emptyX, y: emptyY }
      
      // æ·»åŠ åˆ°æ­£åœ¨ç§»åŠ¨çš„ä¸ªä½“é›†åˆ
      this.movingAgents.add(`${emptyX}-${emptyY}`)
      
      // 3ç§’åä»ç§»åŠ¨é›†åˆä¸­ç§»é™¤
      setTimeout(() => {
        this.movingAgents.delete(`${emptyX}-${emptyY}`)
        this.updateVisualization() // æ›´æ–°å¯è§†åŒ–ä»¥ç§»é™¤é—ªçƒæ•ˆæœ
      }, 1000)
      
      // ç§»åŠ¨
      this.grid[emptyX][emptyY] = this.grid[agentX][agentY]
      this.grid[agentX][agentY] = 0
      
      this.iterations++
      this.calculateStatistics()
      this.updateVisualization()
      
      // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä¸ªä½“éƒ½æ»¡æ„äº†ï¼ˆåœ¨ç»Ÿè®¡æ•°æ®æ›´æ–°åæ£€æŸ¥ï¼‰
      if (this.unsatisfiedCount === 0) {
        // åœæ­¢è‡ªåŠ¨æ¨¡æ‹Ÿ
        if (this.isSimulating) {
          this.stopSimulation()
        }
        
        // å»¶è¿Ÿå¼¹å‡ºå¯¹è¯æ¡†ï¼Œç¡®ä¿ç•Œé¢æ›´æ–°å®Œæˆ
        setTimeout(() => {
          this.$confirm(
            `æ¨¡æ‹Ÿå·²å®Œæˆï¼æ‰€æœ‰ä¸ªä½“éƒ½å·²æ»¡æ„ã€‚\n\næœ€ç»ˆç»Ÿè®¡æ•°æ®ï¼š\n- æ€»è¿­ä»£æ¬¡æ•°ï¼š${this.iterations}\n- éš”ç¦»æŒ‡æ•°ï¼š${this.segregationIndex}%\n- `,
            'æ¨¡æ‹Ÿç»“æŸ',
            {
              confirmButtonText: 'æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š',
              cancelButtonText: 'å…³é—­',
              type: 'success',
              showCancelButton: true
            }
          ).then(() => {
            // ç”¨æˆ·ç‚¹å‡»æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Šï¼Œæ‰“å¼€ä»ªè¡¨ç›˜
            this.showDashboardDialog = true
          }).catch(() => {
            // ç”¨æˆ·ç‚¹å‡»å…³é—­ï¼Œä¸åšä»»ä½•æ“ä½œ
          })
        }, 100)
      }
      
      // è®°å½•å†å²æ•°æ®
      this.historyData.iterations.push(this.iterations)
      this.historyData.segregationIndex.push(parseFloat(this.segregationIndex))
      this.historyData.unsatisfiedCount.push(this.unsatisfiedCount)
      
      // æ›´æ–°æ”¶æ•›æ€§æ•°æ®
      this.updateConvergenceData()
      
      // å¦‚æœä»ªè¡¨ç›˜å¯¹è¯æ¡†æ‰“å¼€ï¼Œæ›´æ–°ä»ªè¡¨ç›˜
      if (this.showDashboardDialog) {
        // æ›´æ–°æŠ˜çº¿å›¾
        this.updateChart()
        
        // æ›´æ–°ä»ªè¡¨ç›˜å’Œé¥¼å›¾
        this.updateGauge()
        this.updatePieChart()
        this.updateConvergenceChart()
      }
      
      // å¦‚æœå½“å‰æ˜¯çƒ­åŠ›å›¾è§†å›¾ï¼Œä¹Ÿæ›´æ–°çƒ­åŠ›å›¾
      if (this.activeView === 'heatmap') {
        this.updateHeatmap()
      } else if (this.activeView === 'satisfaction') {
        this.updateSatisfactionHeatmap()
      } else if (this.activeView === 'trajectories') {
        this.updateTrajectories()
      }
      
      return true
    },
    
    isSatisfied(x, y) {
      const agentType = this.grid[x][y]
      if (agentType === 0) return true
      
      let sameTypeCount = 0
      let totalNeighbors = 0
      
      // æ£€æŸ¥8ä¸ªé‚»å±…
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue
          
          const nx = x + dx
          const ny = y + dy
          
          if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {
            if (this.grid[nx][ny] !== 0) {
              totalNeighbors++
              if (this.grid[nx][ny] === agentType) {
                sameTypeCount++
              }
            }
          }
        }
      }
      
      if (totalNeighbors === 0) return true
      return (sameTypeCount / totalNeighbors) >= this.threshold
    },
    
    
    calculateStatistics() {
      let unsatisfied = 0
      let totalAgents = 0
      let segregationSum = 0
      
      // é‡ç½®æ»¡æ„åº¦åˆ†å¸ƒæ•°æ®
      this.satisfactionDistribution = {
        satisfied: { type1: 0, type2: 0 },
        unsatisfied: { type1: 0, type2: 0 }
      }
      
      for (let i = 0; i < this.gridSize; i++) {
        for (let j = 0; j < this.gridSize; j++) {
          if (this.grid[i][j] !== 0) {
            totalAgents++
            const isSatisfied = this.isSatisfied(i, j)
            
            // æ›´æ–°æ»¡æ„åº¦åˆ†å¸ƒæ•°æ®
            if (this.grid[i][j] === 1) {
              if (isSatisfied) {
                this.satisfactionDistribution.satisfied.type1++
              } else {
                this.satisfactionDistribution.unsatisfied.type1++
              }
            } else {
              if (isSatisfied) {
                this.satisfactionDistribution.satisfied.type2++
              } else {
                this.satisfactionDistribution.unsatisfied.type2++
              }
            }
            
            if (!isSatisfied) {
              unsatisfied++
            }
            
            // è®¡ç®—éš”ç¦»æŒ‡æ•°
            const neighbors = this.getNeighbors(i, j)
            const sameType = neighbors.filter(n => n === this.grid[i][j]).length
            if (neighbors.length > 0) {
              segregationSum += sameType / neighbors.length
            }
          }
        }
      }
      
      this.unsatisfiedCount = unsatisfied
      this.segregationIndex = totalAgents > 0 ? ((segregationSum / totalAgents) * 100).toFixed(1) : 0
    },
    
    getNeighbors(x, y) {
      const neighbors = []
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue
          
          const nx = x + dx
          const ny = y + dy
          
          if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize && this.grid[nx][ny] !== 0) {
            neighbors.push(this.grid[nx][ny])
          }
        }
      }
      return neighbors
    },
    
   renderGrid() {
  const container = this.$refs.gridContainer
  if (!container) return
  
  d3.select(container).selectAll("*").remove()
  
  // è·å–å®¹å™¨å°ºå¯¸å¹¶æ·»åŠ å®‰å…¨æ£€æŸ¥
  const containerWidth = Math.min(container.clientWidth, 1000) // å¢å¤§æœ€å¤§å®½åº¦é™åˆ¶
  const containerHeight = Math.min(container.clientHeight, 700) // å¢å¤§æœ€å¤§é«˜åº¦é™åˆ¶
  
  // ç¡®ä¿å®¹å™¨æœ‰æœ‰æ•ˆå°ºå¯¸
  if (containerWidth < 100 || containerHeight < 100) {
    console.warn('å®¹å™¨å°ºå¯¸è¿‡å°ï¼Œè·³è¿‡æ¸²æŸ“')
    return
  }
  
  // å‡å°‘è¾¹è·ï¼Œç¡®ä¿ç½‘æ ¼èƒ½å®Œæ•´æ˜¾ç¤º
  const margin = 20 // å‡å°‘è¾¹è·é‡Šæ”¾æ›´å¤šç©ºé—´
  const availableWidth = containerWidth - margin * 2
  const availableHeight = containerHeight - margin * 2
  
  // è®¡ç®—å•å…ƒæ ¼å¤§å°ï¼Œç¡®ä¿ç½‘æ ¼èƒ½å®Œæ•´æ˜¾ç¤ºï¼Œä½¿ç”¨æ›´å¤§çš„ç¼©æ”¾å› å­
  const cellSize = Math.min(
    Math.floor(availableWidth / this.gridSize),
    Math.floor(availableHeight / this.gridSize),
    35 // å¢å¤§æœ€å¤§å•å…ƒæ ¼å°ºå¯¸
  ) * 0.95 // ä½¿ç”¨æ›´å¤§çš„ç¼©æ”¾å› å­
  
  // ç¡®ä¿å•å…ƒæ ¼å°ºå¯¸æœ‰æ•ˆ
  if (cellSize < 3) {
    console.warn('è®¡ç®—å‡ºçš„å•å…ƒæ ¼å°ºå¯¸è¿‡å°ï¼Œè·³è¿‡æ¸²æŸ“')
    return
  }
  
  const width = cellSize * this.gridSize
  const height = cellSize * this.gridSize
  
  // å±…ä¸­æ”¾ç½®ç½‘æ ¼ï¼Œç¡®ä¿ä¸è¶…å‡ºå®¹å™¨è¾¹ç•Œ
  const offsetX = Math.max(margin, (containerWidth - width) / 2)
  const offsetY = Math.max(margin, (containerHeight - height) / 2)
  
  const svg = d3.select(container)
    .append("svg")
    .attr("width", containerWidth)
    .attr("height", containerHeight)
    .style("border", "1px solid #ddd") // æ·»åŠ è¾¹æ¡†ä¾¿äºè°ƒè¯•
    .append("g")
    .attr("transform", `translate(${offsetX}, ${offsetY})`)
  
  // æ·»åŠ ç½‘æ ¼èƒŒæ™¯
  svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "#f0f0f0")
    .attr("stroke", "#ccc")
    .attr("stroke-width", 1)
  
  // åˆ›å»ºé¢œè‰²æ–¹æ¡ˆï¼Œè€ƒè™‘æ»¡æ„åº¦å’Œç§»åŠ¨çŠ¶æ€
  const getColor = (value, isSatisfied, isMoving) => {
    if (value === 0) return "#f8f9fa"; // ç©ºç½®å•å…ƒæ ¼
    
    // å¦‚æœæ˜¯æ­£åœ¨ç§»åŠ¨çš„ä¸ªä½“ï¼Œæ·»åŠ é—ªçƒæ•ˆæœ
    if (isMoving) {
      return value === 1 ? "#ff9ff3" : "#00d2d3"; // é—ªçƒé¢œè‰²
    }
    
    if (value === 1) {
      return isSatisfied ? "#ff7675" : "#fab1a0"; // ç±»å‹1ï¼šæ»¡æ„=æ·±è‰²ï¼Œä¸æ»¡æ„=æµ…è‰²
    } else {
      return isSatisfied ? "#74b9ff" : "#a0d2f3"; // ç±»å‹2ï¼šæ»¡æ„=æ·±è‰²ï¼Œä¸æ»¡æ„=æµ…è‰²
    }
  }
  
  // æ·»åŠ ç½‘æ ¼çº¿ - ä»…å½“å•å…ƒæ ¼è¶³å¤Ÿå¤§æ—¶æ‰æ˜¾ç¤º
  if (cellSize >= 5) { // é™ä½ç½‘æ ¼çº¿æ˜¾ç¤ºé˜ˆå€¼
    for (let i = 0; i <= this.gridSize; i++) {
      // å‚ç›´çº¿
      svg.append("line")
        .attr("x1", i * cellSize)
        .attr("y1", 0)
        .attr("x2", i * cellSize)
        .attr("y2", height)
        .attr("stroke", "#ddd")
        .attr("stroke-width", 0.5)
      
      // æ°´å¹³çº¿
      svg.append("line")
        .attr("x1", 0)
        .attr("y1", i * cellSize)
        .attr("x2", width)
        .attr("y2", i * cellSize)
        .attr("stroke", "#ddd")
        .attr("stroke-width", 0.5)
    }
  }
  
  // åˆ›å»ºå•å…ƒæ ¼
  this.cells = svg.selectAll(".cell")
    .data(this.grid.flat().map((d, i) => ({
      value: d,
      x: i % this.gridSize,
      y: Math.floor(i / this.gridSize),
      isSatisfied: d !== 0 ? this.isSatisfied(Math.floor(i / this.gridSize), i % this.gridSize) : true
    })))
    .enter()
    .append("g")
    .attr("class", "cell")
    .attr("transform", d => `translate(${d.x * cellSize}, ${d.y * cellSize})`)
  
  // æ·»åŠ å•å…ƒæ ¼èƒŒæ™¯ï¼Œé¢œè‰²åæ˜ ç±»å‹ã€æ»¡æ„åº¦å’Œç§»åŠ¨çŠ¶æ€
  this.cellRects = this.cells.append("rect")
    .attr("width", cellSize - 0.5) // ç•¥å°äºcellSizeï¼Œåˆ›å»ºé—´éš™
    .attr("height", cellSize - 0.5)
    .attr("fill", d => getColor(
      d.value, 
      d.isSatisfied, 
      this.movingAgents.has(`${d.y}-${d.x}`)
    ))
    .attr("stroke", "none")
    .attr("rx", Math.min(3, cellSize / 6)) // å¢å¤§åœ†è§’
    .attr("ry", Math.min(3, cellSize / 6))
    .on("mouseover", (event, d) => {
      // æ˜¾ç¤ºæç¤ºä¿¡æ¯
      if (d.value !== 0) {
        const neighbors = this.getNeighbors(d.y, d.x)
        const sameType = neighbors.filter(n => n === d.value).length
        const ratio = neighbors.length > 0 ? (sameType / neighbors.length).toFixed(2) : 0
        const isSatisfied = d.isSatisfied ? "æ»¡æ„" : "ä¸æ»¡æ„"
        const typeText = d.value === 1 ? "ç±»å‹1" : "ç±»å‹2"
        
        const tooltip = d3.select("body").append("div")
          .attr("class", "grid-tooltip")
          .style("position", "absolute")
          .style("background", "rgba(0,0,0,0.7)")
          .style("color", "white")
          .style("padding", "8px")
          .style("border-radius", "4px")
          .style("font-size", "12px")
          .style("pointer-events", "none")
          .style("z-index", 1000)
          .style("left", `${event.pageX + 10}px`)
          .style("top", `${event.pageY - 28}px`)
          .html(`
            <div>${typeText} (${isSatisfied})</div>
            <div>ä½ç½®: (${d.x}, ${d.y})</div>
            <div>ç›¸åŒç±»å‹é‚»å±…: ${sameType}/${neighbors.length} (${(ratio * 100).toFixed(0)}%)</div>
            <div>æ»¡æ„é˜ˆå€¼: ${this.threshold * 100}%</div>
          `)
      }
    })
    .on("mouseout", (event) => {
      // ç§»é™¤æç¤ºä¿¡æ¯
      d3.selectAll(".grid-tooltip").remove()
    })
  
  // æ·»åŠ æ–‡å­—æ ‡ç­¾ï¼Œé™ä½æ˜¾ç¤ºé˜ˆå€¼
  if (cellSize >= 8) { // é™ä½æ–‡å­—æ˜¾ç¤ºé˜ˆå€¼
    this.cells.filter(d => d.value !== 0)
      .append("text")
      .attr("x", cellSize / 2)
      .attr("y", cellSize / 2)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .attr("font-size", `${Math.max(cellSize / 3.5, 9)}px`) // ä½¿ç”¨æ›´å¤§çš„å­—ä½“æ¯”ä¾‹
      .attr("fill", "#fff")
      .attr("font-weight", "bold") // åŠ ç²—æ–‡å­—ï¼Œæé«˜å¯è¯»æ€§
      .text(d => d.value)
  }
  
  // å­˜å‚¨å½“å‰çš„cellSizeä¾›updateVisualizationä½¿ç”¨
  this.currentCellSize = cellSize
},

    updateVisualization() {
  if (!this.cells || !this.currentCellSize) return
  
  const cellSize = this.currentCellSize // ä½¿ç”¨å­˜å‚¨çš„cellSize

  // åˆ›å»ºé¢œè‰²æ–¹æ¡ˆï¼Œè€ƒè™‘æ»¡æ„åº¦å’Œç§»åŠ¨çŠ¶æ€
  const getColor = (value, isSatisfied, isMoving) => {
    if (value === 0) return "#f8f9fa"; // ç©ºç½®å•å…ƒæ ¼
    
    // å¦‚æœæ˜¯æ­£åœ¨ç§»åŠ¨çš„ä¸ªä½“ï¼Œæ·»åŠ é—ªçƒæ•ˆæœ
    if (isMoving) {
      return value === 1 ? "#ff9ff3" : "#00d2d3"; // é—ªçƒé¢œè‰²
    }
    
    if (value === 1) {
      return isSatisfied ? "#ff7675" : "#fab1a0"; // ç±»å‹1ï¼šæ»¡æ„=æ·±è‰²ï¼Œä¸æ»¡æ„=æµ…è‰²
    } else {
      return isSatisfied ? "#74b9ff" : "#a0d2f3"; // ç±»å‹2ï¼šæ»¡æ„=æ·±è‰²ï¼Œä¸æ»¡æ„=æµ…è‰²
    }
  }

  // æ›´æ–°å•å…ƒæ ¼æ•°æ®
  const cellData = this.grid.flat().map((d, i) => ({
    value: d,
    x: i % this.gridSize,
    y: Math.floor(i / this.gridSize),
    isSatisfied: d !== 0 ? this.isSatisfied(Math.floor(i / this.gridSize), i % this.gridSize) : true
  }))

  // æ›´æ–°å•å…ƒæ ¼é¢œè‰²
  this.cells
    .data(cellData)
    .select("rect")
    .attr("fill", d => getColor(
      d.value, 
      d.isSatisfied, 
      this.movingAgents.has(`${d.y}-${d.x}`)
    ))

  // ç§»é™¤æ‰€æœ‰ç°æœ‰çš„æ–‡å­—æ ‡ç­¾
  this.cells.selectAll("text").remove()

  // é‡æ–°æ·»åŠ æ–‡å­—æ ‡ç­¾ï¼Œä»…å½“å•å…ƒæ ¼è¶³å¤Ÿå¤§æ—¶æ˜¾ç¤º
  if (cellSize >= 8) { // é™ä½æ–‡å­—æ˜¾ç¤ºé˜ˆå€¼
    this.cells
      .data(cellData)
      .filter(d => d.value !== 0)
      .append("text")
      .attr("x", cellSize / 2)
      .attr("y", cellSize / 2)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .attr("font-size", `${Math.max(cellSize / 3.5, 9)}px`) // ä½¿ç”¨æ›´å¤§çš„å­—ä½“æ¯”ä¾‹
      .attr("fill", "#fff")
      .attr("font-weight", "bold") // åŠ ç²—æ–‡å­—ï¼Œæé«˜å¯è¯»æ€§
      .text(d => d.value)
  }
},
    
   renderHeatmap() {
  const container = this.$refs.heatmapContainer
  if (!container) return
  
  d3.select(container).selectAll("*").remove()
  
  // è·å–å®¹å™¨å°ºå¯¸
  const containerWidth = container.clientWidth
  const containerHeight = container.clientHeight
  
  // å¢åŠ è¾¹è·
  const margin = { top: 40, right: 40, bottom: 60, left: 40 }
  const additionalMargin = 40 // é¢å¤–è¾¹è·
  const downShift = 80// æ•´ä½“ä¸‹ç§»çš„è·ç¦»
  
  // åº”ç”¨ç¼©æ”¾å› å­0.8
  const scaleFactor = 0.8
  const width = (containerWidth - margin.left - margin.right - additionalMargin * 2) * scaleFactor
  const height = (containerHeight - margin.top - margin.bottom - additionalMargin * 2) * scaleFactor
  
  // è°ƒæ•´ä½ç½®ä»¥ä¿æŒå±…ä¸­ï¼Œå¹¶æ•´ä½“ä¸‹ç§»
  const offsetX = (containerWidth - width - margin.left - margin.right) / 2
  const offsetY = additionalMargin / 2 + downShift // å¢åŠ ä¸‹ç§»è·ç¦»
  
  const svg = d3.select(container)
    .append("svg")
    .attr("width", containerWidth)
    .attr("height", containerHeight)
    .append("g")
    .attr("transform", `translate(${margin.left + offsetX},${margin.top + offsetY})`)
  
  // å‡†å¤‡çƒ­åŠ›å›¾æ•°æ®
  const heatmapData = []
  for (let i = 0; i < this.gridSize; i++) {
    for (let j = 0; j < this.gridSize; j++) {
      const value = this.heatmapType === 'type1' 
        ? (this.grid[i][j] === 1 ? 1 : 0)
        : (this.grid[i][j] === 2 ? 1 : 0)
      
      heatmapData.push({
        x: j,
        y: i,
        value: value
      })
    }
  }
  
  // åˆ›å»ºæ¯”ä¾‹å°º
  const x = d3.scaleLinear()
    .domain([0, this.gridSize])
    .range([0, width])
  
  const y = d3.scaleLinear()
    .domain([0, this.gridSize])
    .range([0, height])
  
  // ä½¿ç”¨æ’å€¼çš„çƒ­åŠ›å›¾
  // åˆ›å»ºå¯†åº¦æ•°æ®çŸ©é˜µ
  const resolution = 100
  const densityData = new Array(resolution)
    .fill(0)
    .map(() => new Array(resolution).fill(0))
  
  // ä½¿ç”¨é«˜æ–¯æ ¸å‡½æ•°è¿›è¡Œå¹³æ»‘æ’å€¼
  const sigma = 10
  const gaussianKernel = (x, y, centerX, centerY) => {
    const dx = x - centerX
    const dy = y - centerY
    return Math.exp(-(dx*dx + dy*dy) / (2 * sigma * sigma))
  }
  
  // å¡«å……å¯†åº¦æ•°æ®
  for (const point of heatmapData) {
    if (point.value === 0) continue // è·³è¿‡ç©ºå€¼
    
    const centerX = (point.x / this.gridSize) * resolution
    const centerY = (point.y / this.gridSize) * resolution
    
    // å¯¹å‘¨å›´åŒºåŸŸåº”ç”¨é«˜æ–¯æ ¸
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        densityData[j][i] += point.value * gaussianKernel(i, j, centerX, centerY)
      }
    }
  }
  
  // å½’ä¸€åŒ–æ•°æ®
  let max = 0
  for (let i = 0; i < resolution; i++) {
    for (let j = 0; j < resolution; j++) {
      max = Math.max(max, densityData[j][i])
    }
  }
  
  if (max > 0) {
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        densityData[j][i] /= max
      }
    }
  }
  
  // åˆ›å»ºcanvaså…ƒç´ ç”¨äºæ¸²æŸ“çƒ­åŠ›å›¾
  const canvas = document.createElement('canvas')
  canvas.width = resolution
  canvas.height = resolution
  const context = canvas.getContext('2d')
  const imageData = context.createImageData(resolution, resolution)
  
  // å¡«å……å›¾åƒæ•°æ®
  const colorScale = this.heatmapType === 'type1' 
    ? d3.interpolateReds
    : d3.interpolateBlues
  
  for (let i = 0; i < resolution; i++) {
    for (let j = 0; j < resolution; j++) {
      const value = densityData[j][i]
      const color = d3.color(colorScale(value))
      const index = (j * resolution + i) * 4
      
      imageData.data[index] = color.r
      imageData.data[index + 1] = color.g
      imageData.data[index + 2] = color.b
      imageData.data[index + 3] = 255 * Math.min(1, value * 1.5) // é€æ˜åº¦
    }
  }
  
  context.putImageData(imageData, 0, 0)
  
  // å°†canvaså†…å®¹è½¬ä¸ºå›¾åƒ
  const dataUrl = canvas.toDataURL()
  
  // æ·»åŠ çƒ­åŠ›å›¾èƒŒæ™¯
  svg.append("image")
    .attr("width", width)
    .attr("height", height)
    .attr("preserveAspectRatio", "none")
    .attr("xlink:href", dataUrl)
  
  // æ·»åŠ ç½‘æ ¼çº¿
  svg.append("g")
    .attr("class", "grid-lines")
    .selectAll("line")
    .data(d3.range(0, this.gridSize + 1))
    .enter()
    .append("line")
    .attr("x1", d => x(d))
    .attr("y1", 0)
    .attr("x2", d => x(d))
    .attr("y2", height)
    .attr("stroke", "#ddd")
    .attr("stroke-width", 1)
    .attr("stroke-opacity", 0.5)
  
  svg.append("g")
    .attr("class", "grid-lines")
    .selectAll("line")
    .data(d3.range(0, this.gridSize + 1))
    .enter()
    .append("line")
    .attr("x1", 0)
    .attr("y1", d => y(d))
    .attr("x2", width)
    .attr("y2", d => y(d))
    .attr("stroke", "#ddd")
    .attr("stroke-width", 1)
    .attr("stroke-opacity", 0.5)
  
  // æ·»åŠ åæ ‡è½´
  const xAxis = d3.axisBottom(x.copy().domain([1, this.gridSize]))
    .ticks(Math.min(this.gridSize, 10))
  
  const yAxis = d3.axisLeft(y.copy().domain([1, this.gridSize]))
    .ticks(Math.min(this.gridSize, 10))
  
  svg.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0, ${height})`)
    .call(xAxis)
  
  svg.append("g")
    .attr("class", "y-axis")
    .call(yAxis)
  
  // æ·»åŠ åæ ‡è½´æ ‡ç­¾
  svg.append("text")
    .attr("class", "x-label")
    .attr("text-anchor", "middle")
    .attr("x", width / 2)
    .attr("y", height + 40)
    .text("X åæ ‡")
  
  svg.append("text")
    .attr("class", "y-label")
    .attr("text-anchor", "middle")
    .attr("transform", `translate(-30, ${height / 2}) rotate(-90)`)
    .text("Y åæ ‡")
  
  // æ·»åŠ å›¾ä¾‹
  const legendWidth = 200
  const legendHeight = 20
  
  const legendX = width - legendWidth - 10
  const legendY = -30
  
  const legendScale = d3.scaleLinear()
    .domain([0, 1])
    .range([0, legendWidth])
  
  const legendAxis = d3.axisBottom(legendScale)
    .ticks(5)
    .tickFormat(d => d.toFixed(1))
  
  const defs = svg.append("defs")
  
  // åˆ›å»ºçº¿æ€§æ¸å˜
  const gradient = defs.append("linearGradient")
    .attr("id", "density-gradient")
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%")
  
  // æ·»åŠ æ¸å˜é¢œè‰²
  const numStops = 10
  for (let i = 0; i <= numStops; i++) {
    const offset = i / numStops
    gradient.append("stop")
      .attr("offset", `${offset * 100}%`)
      .attr("stop-color", colorScale(offset))
  }
  
  // æ·»åŠ å›¾ä¾‹çŸ©å½¢
  svg.append("rect")
    .attr("x", legendX)
    .attr("y", legendY)
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .style("fill", "url(#density-gradient)")
  
  // æ·»åŠ å›¾ä¾‹è½´
  svg.append("g")
    .attr("class", "legend-axis")
    .attr("transform", `translate(${legendX}, ${legendY + legendHeight})`)
    .call(legendAxis)
  
  // æ·»åŠ å›¾ä¾‹æ ‡é¢˜
  svg.append("text")
    .attr("class", "legend-title")
    .attr("x", legendX + legendWidth / 2)
    .attr("y", legendY - 10)
    .attr("text-anchor", "middle")
    .text(this.heatmapType === 'type1' ? "ç±»å‹1å¯†åº¦" : "ç±»å‹2å¯†åº¦")
},


updateHeatmap() {
      if (this.activeView === 'heatmap') {
        this.renderHeatmap()
      }
    },
    
    renderChart() {
      const container = this.$refs.chartContainer
      if (!container) return
      
      d3.select(container).selectAll("*").remove()
      
      // è·å–å®¹å™¨å°ºå¯¸
      const containerWidth = container.clientWidth
      const containerHeight = 200
      
      // è®¡ç®—è¾¹è·
      const margin = { top: 20, right: 20, bottom: 30, left: 40 }
      const width = containerWidth - margin.left - margin.right
      const height = containerHeight - margin.top - margin.bottom
      
      this.chartSvg = d3.select(container)
        .append("svg")
        .attr("width", containerWidth)
        .attr("height", containerHeight)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`)
      
      // åˆ›å»ºæ¯”ä¾‹å°º
      const x = d3.scaleLinear()
        .domain([0, Math.max(1, d3.max(this.historyData.iterations))])
        .range([0, width])
      
      const y = d3.scaleLinear()
        .domain([0, Math.max(100, d3.max(this.historyData.segregationIndex) * 1.2)])
        .range([height, 0])
      
      const y2 = d3.scaleLinear()
        .domain([0, Math.max(1, d3.max(this.historyData.unsatisfiedCount) * 1.2)])
        .range([height, 0])
      
      this.chartScales = { x, y, y2 }
      
      // æ·»åŠ åæ ‡è½´
      this.chartSvg.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(5))
      
      this.chartSvg.append("g")
        .attr("class", "y-axis")
        .call(d3.axisLeft(y).ticks(5))
      
      this.chartSvg.append("g")
        .attr("class", "y2-axis")
        .attr("transform", `translate(${width}, 0)`)
        .call(d3.axisRight(y2).ticks(5))
      
      // æ·»åŠ åæ ‡è½´æ ‡ç­¾
      this.chartSvg.append("text")
        .attr("class", "x-label")
        .attr("text-anchor", "middle")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom - 5)
        .attr("font-size", "10px")
        .text("è¿­ä»£æ¬¡æ•°")
      
      this.chartSvg.append("text")
        .attr("class", "y-label")
        .attr("text-anchor", "middle")
        .attr("transform", `rotate(-90)`)
        .attr("x", -height / 2)
        .attr("y", -margin.left + 15)
        .attr("font-size", "10px")
        .text("éš”ç¦»æŒ‡æ•° (%)")
      
      this.chartSvg.append("text")
        .attr("class", "y2-label")
        .attr("text-anchor", "middle")
        .attr("transform", `rotate(90)`)
        .attr("x", height / 2)
        .attr("y", -width - margin.right + 15)
        .attr("font-size", "10px")
        .text("ä¸æ»¡æ„ä¸ªä½“æ•°")
      
      // åˆ›å»ºæŠ˜çº¿
      const segregationLine = d3.line()
        .x(d => x(d[0]))
        .y(d => y(d[1]))
      
      const unsatisfiedLine = d3.line()
        .x(d => x(d[0]))
        .y(d => y2(d[1]))
      
      // æ·»åŠ éš”ç¦»æŒ‡æ•°æŠ˜çº¿
      this.chartSvg.append("path")
        .datum(this.historyData.iterations.map((d, i) => [d, this.historyData.segregationIndex[i]]))
        .attr("class", "segregation-line")
        .attr("fill", "none")
        .attr("stroke", "#ff7675")
        .attr("stroke-width", 2)
        .attr("d", segregationLine)
      
      // æ·»åŠ ä¸æ»¡æ„ä¸ªä½“æ•°æŠ˜çº¿
      this.chartSvg.append("path")
        .datum(this.historyData.iterations.map((d, i) => [d, this.historyData.unsatisfiedCount[i]]))
        .attr("class", "unsatisfied-line")
        .attr("fill", "none")
        .attr("stroke", "#74b9ff")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5")
        .attr("d", unsatisfiedLine)
      
      // æ·»åŠ å›¾ä¾‹
      const legend = this.chartSvg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width - 100}, 0)`)
      
      // éš”ç¦»æŒ‡æ•°å›¾ä¾‹
      legend.append("line")
        .attr("x1", 0)
        .attr("y1", 10)
        .attr("x2", 20)
        .attr("y2", 10)
        .attr("stroke", "#ff7675")
        .attr("stroke-width", 2)
      
      legend.append("text")
        .attr("x", 25)
        .attr("y", 10)
        .attr("alignment-baseline", "middle")
        .attr("font-size", "10px")
        .text("éš”ç¦»æŒ‡æ•°")
      
      // ä¸æ»¡æ„ä¸ªä½“æ•°å›¾ä¾‹
      legend.append("line")
        .attr("x1", 0)
        .attr("y1", 30)
        .attr("x2", 20)
        .attr("y2", 30)
        .attr("stroke", "#74b9ff")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5")
      
      legend.append("text")
        .attr("x", 25)
        .attr("y", 30)
        .attr("alignment-baseline", "middle")
        .attr("font-size", "10px")
        .text("ä¸æ»¡æ„ä¸ªä½“")
    },
    
    updateChart() {
      if (!this.chartSvg || !this.chartScales) return
      
      const { x, y, y2 } = this.chartScales
      
      // æ›´æ–°Xè½´æ¯”ä¾‹å°º
      x.domain([0, Math.max(1, d3.max(this.historyData.iterations))])
      
      // æ›´æ–°Yè½´æ¯”ä¾‹å°º
      y.domain([0, Math.max(100, d3.max(this.historyData.segregationIndex) * 1.2)])
      y2.domain([0, Math.max(1, d3.max(this.historyData.unsatisfiedCount) * 1.2)])
      
      // æ›´æ–°åæ ‡è½´
      this.chartSvg.select(".x-axis")
        .call(d3.axisBottom(x).ticks(5))
      
      this.chartSvg.select(".y-axis")
        .call(d3.axisLeft(y).ticks(5))
      
      this.chartSvg.select(".y2-axis")
        .call(d3.axisRight(y2).ticks(5))
      
      // æ›´æ–°æŠ˜çº¿
      const segregationLine = d3.line()
        .x(d => x(d[0]))
        .y(d => y(d[1]))
      
      const unsatisfiedLine = d3.line()
        .x(d => x(d[0]))
        .y(d => y2(d[1]))
      
      this.chartSvg.select(".segregation-line")
        .datum(this.historyData.iterations.map((d, i) => [d, this.historyData.segregationIndex[i]]))
        .attr("d", segregationLine)
      
      this.chartSvg.select(".unsatisfied-line")
        .datum(this.historyData.iterations.map((d, i) => [d, this.historyData.unsatisfiedCount[i]]))
        .attr("d", unsatisfiedLine)
    },
    // æ›´æ–°æ”¶æ•›æ€§æ•°æ®
    // å…¨æ–°çš„æ”¶æ•›æ€§åˆ†æç®—æ³•
updateConvergenceData() {
    // ç¡®ä¿æœ‰è¶³å¤Ÿçš„å†å²æ•°æ®è¿›è¡Œåˆ†æ
    if (this.historyData.segregationIndex.length < 5) return
    
    const indices = this.historyData.segregationIndex
    const iterations = this.historyData.iterations
    const currentIndex = parseFloat(this.segregationIndex)
    const currentIteration = this.iterations
    
    // 1. è®¡ç®—çŸ­æœŸå’Œé•¿æœŸå˜åŒ–ç‡
    const shortTermWindow = Math.min(5, indices.length - 1) // æœ€è¿‘5æ¬¡è¿­ä»£
    const longTermWindow = Math.min(15, indices.length - 1) // æœ€è¿‘15æ¬¡è¿­ä»£
    
    // çŸ­æœŸå˜åŒ–ç‡ï¼ˆæœ€è¿‘5æ¬¡ï¼‰
    const shortTermIndices = indices.slice(-shortTermWindow - 1)
    const shortTermVariance = this.calculateVariance(shortTermIndices)
    const shortTermSlope = this.calculateSlope(shortTermIndices)
    
    // é•¿æœŸå˜åŒ–ç‡ï¼ˆæœ€è¿‘15æ¬¡ï¼‰
    const longTermIndices = indices.slice(-longTermWindow - 1)
    const longTermVariance = this.calculateVariance(longTermIndices)
    const longTermSlope = this.calculateSlope(longTermIndices)
    
    // 2. è®¡ç®—æ”¶æ•›é€Ÿåº¦ (åŸºäºæŒ‡æ•°è¡°å‡æ¨¡å‹)
    const recentChanges = []
    for (let i = Math.max(1, indices.length - 10); i < indices.length; i++) {
        recentChanges.push(Math.abs(indices[i] - indices[i-1]))
    }
    
    const avgChangeRate = recentChanges.reduce((sum, val) => sum + val, 0) / recentChanges.length
    const maxChangeRate = Math.max(...recentChanges)
    
    // 3. æ”¶æ•›é€Ÿåº¦è®¡ç®— (è¶Šå°è¶Šæ¥è¿‘æ”¶æ•›)
    const convergenceSpeed = Math.exp(-avgChangeRate * 5) * 100 // æŒ‡æ•°è¡°å‡æ¨¡å‹
    
    // 4. ç¨³å®šæ€§è¯„ä¼°
    const stabilityScore = this.calculateStabilityScore(shortTermVariance, longTermVariance, shortTermSlope)
    
    // 5. æ”¶æ•›è´¨é‡è¯„ä¼° (è€ƒè™‘è¶‹åŠ¿ä¸€è‡´æ€§)
    const trendConsistency = this.calculateTrendConsistency(indices.slice(-10))
    
    // 6. ç»¼åˆæ”¶æ•›è¯„åˆ†
    const convergenceScore = (convergenceSpeed * 0.4 + stabilityScore * 0.4 + trendConsistency * 0.2)
    
    // 7. æ”¶æ•›çŠ¶æ€åˆ¤æ–­
    let convergenceStatus = 'diverging'
    if (convergenceScore > 90 && avgChangeRate < 0.01) {
        convergenceStatus = 'converged'
    } else if (convergenceScore > 70 && avgChangeRate < 0.1) {
        convergenceStatus = 'converging'
    } else if (convergenceScore > 40) {
        convergenceStatus = 'oscillating'
    }
    
    // 8. é¢„æµ‹æœ€ç»ˆæ”¶æ•›å€¼
    const predictedFinalValue = this.predictFinalConvergenceValue(indices)
    
    // 9. å­˜å‚¨æ”¶æ•›æ•°æ®
    this.convergenceData.push({
        iteration: currentIteration,
        segregationIndex: currentIndex,
        convergenceSpeed: Math.round(convergenceSpeed * 100) / 100,
        stabilityScore: Math.round(stabilityScore * 100) / 100,
        trendConsistency: Math.round(trendConsistency * 100) / 100,
        overallScore: Math.round(convergenceScore * 100) / 100,
        avgChangeRate: avgChangeRate,
        maxChangeRate: maxChangeRate,
        shortTermSlope: shortTermSlope,
        longTermSlope: longTermSlope,
        status: convergenceStatus,
        predictedFinal: predictedFinalValue,
        // æ–°å¢å¹³æ»‘æ›²çº¿æ•°æ®
        smoothedIndex: this.calculateSmoothedValue(indices),
        residual: currentIndex - this.calculateSmoothedValue(indices) // æ®‹å·®
    })
    
    // 10. è¯¦ç»†è°ƒè¯•è¾“å‡º
    console.log(`ğŸ”„ æ”¶æ•›åˆ†æ [è¿­ä»£ ${currentIteration}]:`, {
        å½“å‰éš”ç¦»æŒ‡æ•°: currentIndex.toFixed(3),
        å¹³å‡å˜åŒ–ç‡: avgChangeRate.toFixed(6),
        æ”¶æ•›é€Ÿåº¦: convergenceSpeed.toFixed(2) + '%',
        ç¨³å®šæ€§å¾—åˆ†: stabilityScore.toFixed(2),
        è¶‹åŠ¿ä¸€è‡´æ€§: trendConsistency.toFixed(2),
        ç»¼åˆè¯„åˆ†: convergenceScore.toFixed(2),
        æ”¶æ•›çŠ¶æ€: convergenceStatus,
        é¢„æµ‹æœ€ç»ˆå€¼: predictedFinalValue.toFixed(3),
        çŸ­æœŸæ–œç‡: shortTermSlope.toFixed(6),
        é•¿æœŸæ–œç‡: longTermSlope.toFixed(6)
    })
    
    // 11. æ”¶æ•›å®Œæˆåˆ¤æ–­
    if (convergenceStatus === 'converged' && this.convergenceData.length >= 3) {
        const lastThreeStatuses = this.convergenceData.slice(-3).map(d => d.status)
        if (lastThreeStatuses.every(status => status === 'converged')) {
            console.log('ğŸ¯ ç³»ç»Ÿå·²è¾¾åˆ°ç¨³å®šæ”¶æ•›çŠ¶æ€!')
            // å¯ä»¥é€‰æ‹©åœ¨è¿™é‡Œåœæ­¢æ¨¡æ‹Ÿæˆ–å‘å‡ºé€šçŸ¥
        }
    }
},

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ–¹å·®
calculateVariance(values) {
    if (values.length < 2) return 0
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2))
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length
},

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ–œç‡ (çº¿æ€§å›å½’)
calculateSlope(values) {
    if (values.length < 2) return 0
    const n = values.length
    const x = Array.from({length: n}, (_, i) => i)
    const y = values
    
    const sumX = x.reduce((sum, val) => sum + val, 0)
    const sumY = y.reduce((sum, val) => sum + val, 0)
    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0)
    const sumXX = x.reduce((sum, val) => sum + val * val, 0)
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
    return isNaN(slope) ? 0 : slope
},

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ç¨³å®šæ€§å¾—åˆ†
calculateStabilityScore(shortTermVar, longTermVar, slope) {
    // æ–¹å·®è¶Šå°è¶Šç¨³å®šï¼Œæ–œç‡è¶Šæ¥è¿‘0è¶Šç¨³å®š
    const varianceStability = Math.exp(-shortTermVar * 10) * 50
    const slopeStability = Math.exp(-Math.abs(slope) * 100) * 50
    return Math.min(100, varianceStability + slopeStability)
},

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—è¶‹åŠ¿ä¸€è‡´æ€§
calculateTrendConsistency(values) {
    if (values.length < 3) return 50
    
    let consistentTrends = 0
    let totalTrends = 0
    
    for (let i = 2; i < values.length; i++) {
        const trend1 = values[i-1] - values[i-2] // å‰ä¸€ä¸ªè¶‹åŠ¿
        const trend2 = values[i] - values[i-1]   // å½“å‰è¶‹åŠ¿
        
        // åˆ¤æ–­è¶‹åŠ¿æ˜¯å¦ä¸€è‡´ï¼ˆåŒå‘ï¼‰
        if ((trend1 > 0 && trend2 > 0) || (trend1 < 0 && trend2 < 0) || (Math.abs(trend1) < 0.01 && Math.abs(trend2) < 0.01)) {
            consistentTrends++
        }
        totalTrends++
    }
    
    return totalTrends > 0 ? (consistentTrends / totalTrends) * 100 : 50
},

// è¾…åŠ©å‡½æ•°ï¼šé¢„æµ‹æœ€ç»ˆæ”¶æ•›å€¼
predictFinalConvergenceValue(indices) {
    if (indices.length < 10) return indices[indices.length - 1]
    
    // ä½¿ç”¨æŒ‡æ•°åŠ æƒç§»åŠ¨å¹³å‡é¢„æµ‹
    const weights = indices.map((_, i) => Math.exp(i * 0.1)) // æŒ‡æ•°æƒé‡
    const weightedSum = indices.reduce((sum, val, i) => sum + val * weights[i], 0)
    const weightSum = weights.reduce((sum, val) => sum + val, 0)
    
    return weightedSum / weightSum
},

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—å¹³æ»‘å€¼ (ç§»åŠ¨å¹³å‡)
calculateSmoothedValue(indices) {
    if (indices.length < 3) return indices[indices.length - 1]
    
    const windowSize = Math.min(5, indices.length)
    const recentValues = indices.slice(-windowSize)
    return recentValues.reduce((sum, val) => sum + val, 0) / recentValues.length
},
    
    exportData() {
      // å‡†å¤‡å¯¼å‡ºçš„æ•°æ®
      const data = {
        parameters: {
          gridSize: this.gridSize,
          threshold: this.threshold,
          emptyRate: this.emptyRate
        },
        statistics: {
          iterations: this.iterations,
          segregationIndex: this.segregationIndex,
          unsatisfiedCount: this.unsatisfiedCount,
          satisfactionDistribution: this.satisfactionDistribution
        },
        historyData: this.historyData,
        convergenceData: this.convergenceData
      }
      
      // è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
      const jsonString = JSON.stringify(data, null, 2)
      
      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const blob = new Blob([jsonString], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = `schelling_model_data_${new Date().toISOString().slice(0,10)}.json`
      document.body.appendChild(a)
      a.click()
      
      // æ¸…ç†
      setTimeout(() => {
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      }, 0)
    },
    
    // æ¸²æŸ“æ»¡æ„åº¦çƒ­åŠ›å›¾
    renderSatisfactionHeatmap() {
  const container = this.$refs.satisfactionContainer
  if (!container) return
  
  d3.select(container).selectAll("*").remove()
  
  // è·å–å®¹å™¨å°ºå¯¸
  const containerWidth = container.clientWidth
  const containerHeight = container.clientHeight
  
  // è®¡ç®—è¾¹è·
  const margin = { top: 40, right: 40, bottom: 60, left: 40 }
  const additionalMargin = 40 // é¢å¤–è¾¹è·
  const downShift = 80// æ•´ä½“ä¸‹ç§»çš„è·ç¦»
  
  // åº”ç”¨ç¼©æ”¾å› å­0.8
  const scaleFactor = 0.8
  const width = (containerWidth - margin.left - margin.right - additionalMargin * 2) * scaleFactor
  const height = (containerHeight - margin.top - margin.bottom - additionalMargin * 2) * scaleFactor
  
  // è°ƒæ•´ä½ç½®ä»¥ä¿æŒå±…ä¸­ï¼Œå¹¶æ•´ä½“ä¸‹ç§»
  const offsetX = (containerWidth - width - margin.left - margin.right) / 2
  const offsetY = additionalMargin / 2 + downShift // å¢åŠ ä¸‹ç§»è·ç¦»
  
  const svg = d3.select(container)
    .append("svg")
    .attr("width", containerWidth)
    .attr("height", containerHeight)
    .append("g")
    .attr("transform", `translate(${margin.left + offsetX},${margin.top + offsetY})`)
  
  // å‡†å¤‡çƒ­åŠ›å›¾æ•°æ®
  const heatmapData = []
  for (let i = 0; i < this.gridSize; i++) {
    for (let j = 0; j < this.gridSize; j++) {
      if (this.grid[i][j] === 0) {
        // ç©ºå•å…ƒæ ¼
        heatmapData.push({
          x: j,
          y: i,
          value: 0
        })
        continue
      }
      
      // è®¡ç®—æ»¡æ„åº¦
      const neighbors = this.getNeighbors(i, j)
      const sameType = neighbors.filter(n => n === this.grid[i][j]).length
      const satisfactionLevel = neighbors.length > 0 ? sameType / neighbors.length : 0
      
      heatmapData.push({
        x: j,
        y: i,
        value: satisfactionLevel
      })
    }
  }
  
  // åˆ›å»ºæ¯”ä¾‹å°º
  const x = d3.scaleLinear()
    .domain([0, this.gridSize])
    .range([0, width])
  
  const y = d3.scaleLinear()
    .domain([0, this.gridSize])
    .range([0, height])
  
  // ä½¿ç”¨æ’å€¼çš„çƒ­åŠ›å›¾
  // åˆ›å»ºå¯†åº¦æ•°æ®çŸ©é˜µ
  const resolution = 100
  const densityData = new Array(resolution)
    .fill(0)
    .map(() => new Array(resolution).fill(0))
  
  // ä½¿ç”¨é«˜æ–¯æ ¸å‡½æ•°è¿›è¡Œå¹³æ»‘æ’å€¼
  const sigma = 10
  const gaussianKernel = (x, y, centerX, centerY) => {
    const dx = x - centerX
    const dy = y - centerY
    return Math.exp(-(dx*dx + dy*dy) / (2 * sigma * sigma))
  }
  
  // å¡«å……å¯†åº¦æ•°æ®
  for (const point of heatmapData) {
    if (point.value === 0) continue // è·³è¿‡ç©ºå€¼
    
    const centerX = (point.x / this.gridSize) * resolution
    const centerY = (point.y / this.gridSize) * resolution
    
    // å¯¹å‘¨å›´åŒºåŸŸåº”ç”¨é«˜æ–¯æ ¸
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        densityData[j][i] += point.value * gaussianKernel(i, j, centerX, centerY)
      }
    }
  }
  
  // å½’ä¸€åŒ–æ•°æ®
  let max = 0
  for (let i = 0; i < resolution; i++) {
    for (let j = 0; j < resolution; j++) {
      max = Math.max(max, densityData[j][i])
    }
  }
  
  if (max > 0) {
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        densityData[j][i] /= max
      }
    }
  }
  
  // åˆ›å»ºcanvaså…ƒç´ ç”¨äºæ¸²æŸ“çƒ­åŠ›å›¾
  const canvas = document.createElement('canvas')
  canvas.width = resolution
  canvas.height = resolution
  const context = canvas.getContext('2d')
  const imageData = context.createImageData(resolution, resolution)
  
  // å¡«å……å›¾åƒæ•°æ®
  const colorScale = d3.interpolate(d3.rgb(255, 0, 0), d3.rgb(0, 255, 0))
  
  for (let i = 0; i < resolution; i++) {
    for (let j = 0; j < resolution; j++) {
      const value = densityData[j][i]
      const color = d3.color(colorScale(value))
      const index = (j * resolution + i) * 4
      
      imageData.data[index] = color.r
      imageData.data[index + 1] = color.g
      imageData.data[index + 2] = color.b
      imageData.data[index + 3] = 255 * Math.min(1, value * 1.5) // é€æ˜åº¦
    }
  }
  
  context.putImageData(imageData, 0, 0)
  
  // å°†canvaså†…å®¹è½¬ä¸ºå›¾åƒ
  const dataUrl = canvas.toDataURL()
  
  // æ·»åŠ çƒ­åŠ›å›¾èƒŒæ™¯
  svg.append("image")
    .attr("width", width)
    .attr("height", height)
    .attr("preserveAspectRatio", "none")
    .attr("xlink:href", dataUrl)
  
  // æ·»åŠ ç½‘æ ¼çº¿
  svg.append("g")
    .attr("class", "grid-lines")
    .selectAll("line")
    .data(d3.range(0, this.gridSize + 1))
    .enter()
    .append("line")
    .attr("x1", d => x(d))
    .attr("y1", 0)
    .attr("x2", d => x(d))
    .attr("y2", height)
    .attr("stroke", "#ddd")
    .attr("stroke-width", 1)
    .attr("stroke-opacity", 0.5)
  
  svg.append("g")
    .attr("class", "grid-lines")
    .selectAll("line")
    .data(d3.range(0, this.gridSize + 1))
    .enter()
    .append("line")
    .attr("x1", 0)
    .attr("y1", d => y(d))
    .attr("x2", width)
    .attr("y2", d => y(d))
    .attr("stroke", "#ddd")
    .attr("stroke-width", 1)
    .attr("stroke-opacity", 0.5)
  
  // æ·»åŠ åæ ‡è½´
  const xAxis = d3.axisBottom(x.copy().domain([1, this.gridSize]))
    .ticks(Math.min(this.gridSize, 10))
  
  const yAxis = d3.axisLeft(y.copy().domain([1, this.gridSize]))
    .ticks(Math.min(this.gridSize, 10))
  
  svg.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0, ${height})`)
    .call(xAxis)
  
  svg.append("g")
    .attr("class", "y-axis")
    .call(yAxis)
  
  // æ·»åŠ åæ ‡è½´æ ‡ç­¾
  svg.append("text")
    .attr("class", "x-label")
    .attr("text-anchor", "middle")
    .attr("x", width / 2)
    .attr("y", height + 40)
    .text("X åæ ‡")
  
  svg.append("text")
    .attr("class", "y-label")
    .attr("text-anchor", "middle")
    .attr("transform", `translate(-30, ${height / 2}) rotate(-90)`)
    .text("Y åæ ‡")
  
  // æ·»åŠ å›¾ä¾‹
  const legendWidth = 200
  const legendHeight = 20
  
  const legendX = width - legendWidth - 10
  const legendY = -30
  
  const legendScale = d3.scaleLinear()
    .domain([0, 1])
    .range([0, legendWidth])
  
  const legendAxis = d3.axisBottom(legendScale)
    .ticks(5)
    .tickFormat(d => d.toFixed(1))
  
  const defs = svg.append("defs")
  
  // åˆ›å»ºçº¿æ€§æ¸å˜
  const gradient = defs.append("linearGradient")
    .attr("id", "satisfaction-gradient")
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%")
  
  // æ·»åŠ æ¸å˜é¢œè‰²
  const numStops = 10
  for (let i = 0; i <= numStops; i++) {
    const offset = i / numStops
    gradient.append("stop")
      .attr("offset", `${offset * 100}%`)
      .attr("stop-color", colorScale(offset))
  }
  
  // æ·»åŠ å›¾ä¾‹çŸ©å½¢
  svg.append("rect")
    .attr("x", legendX)
    .attr("y", legendY)
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .style("fill", "url(#satisfaction-gradient)")
  
  // æ·»åŠ å›¾ä¾‹è½´
  svg.append("g")
    .attr("class", "legend-axis")
    .attr("transform", `translate(${legendX}, ${legendY + legendHeight})`)
    .call(legendAxis)
  
  // æ·»åŠ å›¾ä¾‹æ ‡é¢˜
  svg.append("text")
    .attr("class", "legend-title")
    .attr("x", legendX + legendWidth / 2)
    .attr("y", legendY - 10)
    .attr("text-anchor", "middle")
    .text("æ»¡æ„åº¦")
},

    
    // æ›´æ–°æ»¡æ„åº¦çƒ­åŠ›å›¾
    updateSatisfactionHeatmap() {
      if (this.activeView === 'satisfaction') {
        this.renderSatisfactionHeatmap()
      }
    },
    
    // æ¸²æŸ“ç§»åŠ¨è½¨è¿¹å›¾
    
    
    // æ¸²æŸ“ä»ªè¡¨ç›˜
    renderGauge() {
  const container = this.$refs.gaugeContainer
  if (!container) return
  
  d3.select(container).selectAll("*").remove()
  
  const containerWidth = container.clientWidth
  const containerHeight = container.clientHeight // ä½¿ç”¨å®¹å™¨å®é™…é«˜åº¦
  
  const margin = { top: 20, right: 20, bottom: 40, left: 20 } // å¢åŠ è¾¹è·
  const width = containerWidth - margin.left - margin.right
  const height = containerHeight - margin.top - margin.bottom
  
  const svg = d3.select(container)
    .append("svg")
    .attr("width", containerWidth)
    .attr("height", containerHeight)
    .append("g")
    .attr("transform", `translate(${margin.left + width / 2}, ${margin.top + height * 0.45})`) // è°ƒæ•´å‚ç›´ä½ç½®
  
  const radius = Math.min(width, height * 0.8) / 2 // å‡å°åŠå¾„ä»¥é€‚åº”å®¹å™¨
  
  // åˆ›å»ºä»ªè¡¨ç›˜æ¯”ä¾‹å°º
  const scale = d3.scaleLinear()
    .domain([0, 100])
    .range([-Math.PI / 2, Math.PI / 2])
  
  // åˆ›å»ºå¼§å½¢ç”Ÿæˆå™¨
  const arc = d3.arc()
    .innerRadius(radius - Math.max(20, radius * 0.3)) // åŠ¨æ€è®¡ç®—å†…åŠå¾„
    .outerRadius(radius)
    .startAngle(-Math.PI / 2)
  
  // æ·»åŠ èƒŒæ™¯å¼§å½¢
  const backgroundArc = svg.append("path")
    .datum({ endAngle: Math.PI / 2 })
    .attr("class", "gauge-background")
    .attr("d", arc)
    .attr("fill", "#ecf0f1")
  
  // åˆ›å»ºæ¸å˜
  const defs = svg.append("defs")
  const gradient = defs.append("linearGradient")
    .attr("id", "gauge-gradient")
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%")
  
  gradient.append("stop")
    .attr("offset", "0%")
    .attr("stop-color", "#2ecc71") // ç»¿è‰²ä»£è¡¨ä½éš”ç¦»
  
  gradient.append("stop")
    .attr("offset", "30%")
    .attr("stop-color", "#f1c40f") // é»„è‰²ä»£è¡¨ä¸­ç­‰éš”ç¦»
  
  gradient.append("stop")
    .attr("offset", "70%")
    .attr("stop-color", "#e67e22") // æ©™è‰²ä»£è¡¨é«˜éš”ç¦»
  
  gradient.append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "#e74c3c") // çº¢è‰²ä»£è¡¨æé«˜éš”ç¦»
  
  // æ·»åŠ å‰æ™¯å¼§å½¢
  const foregroundArc = svg.append("path")
    .datum({ endAngle: scale(parseFloat(this.segregationIndex)) })
    .attr("class", "gauge-foreground")
    .attr("d", arc)
    .attr("fill", "url(#gauge-gradient)")
  
  // æ·»åŠ åˆ»åº¦
  const ticks = [0, 20, 40, 60, 80, 100]
  const innerRadius = radius - Math.max(20, radius * 0.3)
  
  svg.selectAll(".gauge-tick")
    .data(ticks)
    .enter()
    .append("line")
    .attr("class", "gauge-tick")
    .attr("x1", d => innerRadius * Math.cos(scale(d)))
    .attr("y1", d => innerRadius * Math.sin(scale(d)))
    .attr("x2", d => (innerRadius - 10) * Math.cos(scale(d))) // å‘å†…å»¶ä¼¸
    .attr("y2", d => (innerRadius - 10) * Math.sin(scale(d)))
    .attr("stroke", "#7f8c8d")
    .attr("stroke-width", 2)
  
  // åŠ¨æ€è®¡ç®—æ–‡å­—å¤§å°
  const fontSize = Math.max(10, Math.min(14, radius / 8))
  const tickTextRadius = radius + Math.max(12, radius * 0.15)
  
  svg.selectAll(".gauge-tick-text")
    .data(ticks)
    .enter()
    .append("text")
    .attr("class", "gauge-tick-text")
    .attr("x", d => tickTextRadius * Math.cos(scale(d)))
    .attr("y", d => tickTextRadius * Math.sin(scale(d)) + fontSize/3) // è°ƒæ•´å‚ç›´å¯¹é½
    .attr("text-anchor", "middle")
    .attr("font-size", `${fontSize}px`)
    .attr("fill", "#34495e")
    .text(d => d)
  
  // æ·»åŠ æŒ‡é’ˆ
  const pointerLength = radius - Math.max(5, radius * 0.1)
  const pointer = svg.append("line")
    .attr("class", "gauge-pointer")
    .attr("x1", 0)
    .attr("y1", 0)
    .attr("x2", 0)
    .attr("y2", -pointerLength)
    .attr("stroke", "#e74c3c")
    .attr("stroke-width", Math.max(2, radius / 30))
    .attr("stroke-linecap", "round")
    .attr("transform", `rotate(${scale(parseFloat(this.segregationIndex)) * 180 / Math.PI})`)
  
  // æ·»åŠ æŒ‡é’ˆåœ†å¿ƒ
  const centerRadius = Math.max(3, radius / 15)
  svg.append("circle")
    .attr("class", "gauge-center")
    .attr("cx", 0)
    .attr("cy", 0)
    .attr("r", centerRadius)
    .attr("fill", "#e74c3c")
  
  // åŠ¨æ€è®¡ç®—ä¸»å€¼æ–‡å­—å¤§å°å’Œä½ç½®
  const valueFontSize = Math.max(16, Math.min(32, radius / 4))
  const valueY = Math.max(30, radius / 3)
  
  // æ·»åŠ å½“å‰å€¼æ–‡æœ¬
  svg.append("text")
    .attr("class", "gauge-value")
    .attr("x", 0)
    .attr("y", valueY)
    .attr("text-anchor", "middle")
    .attr("font-size", `${valueFontSize}px`)
    .attr("font-weight", "bold")
    .attr("fill", "#2c3e50")
    .text(`${this.segregationIndex}%`)
  
  // åŠ¨æ€è®¡ç®—æ ‡é¢˜æ–‡å­—å¤§å°å’Œä½ç½®
  const titleFontSize = Math.max(12, Math.min(18, radius / 6))
  const titleY = -Math.max(10, radius / 6)
  
  // æ·»åŠ æ ‡é¢˜
  svg.append("text")
    .attr("class", "gauge-title")
    .attr("x", 0)
    .attr("y", titleY)
    .attr("text-anchor", "middle")
    .attr("font-size", `${titleFontSize}px`)
    .attr("font-weight", "600")
    .attr("fill", "#34495e")
    .text("éš”ç¦»æŒ‡æ•°")
  
  // æ·»åŠ å•ä½è¯´æ˜
  const unitFontSize = Math.max(10, Math.min(14, radius / 8))
  svg.append("text")
    .attr("class", "gauge-unit")
    .attr("x", 0)
    .attr("y", valueY + valueFontSize + 5)
    .attr("text-anchor", "middle")
    .attr("font-size", `${unitFontSize}px`)
    .attr("fill", "#7f8c8d")
    .text("Segregation Index")
},

// æ›´æ–°ä»ªè¡¨ç›˜
updateGauge() {
  const container = this.$refs.gaugeContainer
  if (!container) return
  
  const svg = d3.select(container).select("svg").select("g")
  if (svg.empty()) {
    // å¦‚æœSVGä¸å­˜åœ¨ï¼Œé‡æ–°æ¸²æŸ“
    this.renderGauge()
    return
  }
  
  const containerWidth = container.clientWidth
  const containerHeight = container.clientHeight
  
  const margin = { top: 20, right: 20, bottom: 40, left: 20 }
  const width = containerWidth - margin.left - margin.right
  const height = containerHeight - margin.top - margin.bottom
  
  const radius = Math.min(width, height * 0.8) / 2
  
  // åˆ›å»ºä»ªè¡¨ç›˜æ¯”ä¾‹å°º
  const scale = d3.scaleLinear()
    .domain([0, 100])
    .range([-Math.PI / 2, Math.PI / 2])
  
  // æ›´æ–°å¼§å½¢
  const arc = d3.arc()
    .innerRadius(radius - Math.max(20, radius * 0.3))
    .outerRadius(radius)
    .startAngle(-Math.PI / 2)
  
  // æ›´æ–°å‰æ™¯å¼§å½¢ - æ·»åŠ è¿‡æ¸¡åŠ¨ç”»
  svg.select(".gauge-foreground")
    .datum({ endAngle: scale(parseFloat(this.segregationIndex)) })
    .transition()
    .duration(500)
    .attrTween("d", function(d) {
      const interpolate = d3.interpolate(this._current || { endAngle: -Math.PI / 2 }, d)
      this._current = interpolate(0)
      return function(t) {
        return arc(interpolate(t))
      }
    })
  
  // æ›´æ–°æŒ‡é’ˆ - æ·»åŠ è¿‡æ¸¡åŠ¨ç”»
  svg.select(".gauge-pointer")
    .transition()
    .duration(500)
    .attr("transform", `rotate(${scale(parseFloat(this.segregationIndex)) * 180 / Math.PI})`)
  
  // æ›´æ–°å½“å‰å€¼æ–‡æœ¬ - æ·»åŠ æ•°å­—åŠ¨ç”»
  const valueElement = svg.select(".gauge-value")
  const currentValue = parseFloat(valueElement.text()) || 0
  const newValue = parseFloat(this.segregationIndex)
  
  valueElement
    .transition()
    .duration(500)
    .tween("text", function() {
      const interpolate = d3.interpolate(currentValue, newValue)
      return function(t) {
        this.textContent = `${interpolate(t).toFixed(1)}%`
      }
    })
},
    // æ¸²æŸ“é¥¼å›¾
    renderPieChart() {
      const container = this.$refs.pieContainer
      if (!container) return
      
      d3.select(container).selectAll("*").remove()
      
      const containerWidth = container.clientWidth
      const containerHeight = 180
      
      const margin = { top: 10, right: 10, bottom: 10, left: 10 }
      const width = containerWidth - margin.left - margin.right
      const height = containerHeight - margin.top - margin.bottom
      
      const svg = d3.select(container)
        .append("svg")
        .attr("width", containerWidth)
        .attr("height", containerHeight)
        .append("g")
        .attr("transform", `translate(${margin.left + width / 2}, ${margin.top + height / 2})`)
      
      const radius = Math.min(width, height) / 2.5 // å‡å°åŠå¾„ä¸ºé¥¼å›¾ç•™å‡ºæ›´å¤šç©ºé—´ç»™å›¾ä¾‹
      
      // å‡†å¤‡æ•°æ®
      const satisfiedType1 = this.satisfactionDistribution.satisfied.type1
      const unsatisfiedType1 = this.satisfactionDistribution.unsatisfied.type1
      const satisfiedType2 = this.satisfactionDistribution.satisfied.type2
      const unsatisfiedType2 = this.satisfactionDistribution.unsatisfied.type2
      
      const data = [
        { name: "ç±»å‹1æ»¡æ„", value: satisfiedType1, color: "#ff7675" },
        { name: "ç±»å‹1ä¸æ»¡æ„", value: unsatisfiedType1, color: "#fab1a0" },
        { name: "ç±»å‹2æ»¡æ„", value: satisfiedType2, color: "#74b9ff" },
        { name: "ç±»å‹2ä¸æ»¡æ„", value: unsatisfiedType2, color: "#a0d2f3" }
      ].filter(d => d.value > 0)
      
      // åˆ›å»ºé¥¼å›¾ç”Ÿæˆå™¨
      const pie = d3.pie()
        .value(d => d.value)
        .sort(null)
      
      // åˆ›å»ºå¼§å½¢ç”Ÿæˆå™¨
      const arc = d3.arc()
        .innerRadius(0)
        .outerRadius(radius)
      
      // ç»˜åˆ¶é¥¼å›¾
      const arcs = svg.selectAll(".arc")
        .data(pie(data))
        .enter()
        .append("g")
        .attr("class", "arc")
      
      arcs.append("path")
        .attr("d", arc)
        .attr("fill", d => d.data.color)
        .style("cursor", "pointer")
        .on("mouseover", (event, d) => {
          // æ·»åŠ hoveræ•ˆæœ
          d3.select(event.currentTarget).style("opacity", 0.8)
          
          // ç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§tooltip
          d3.selectAll(".pie-tooltip").remove()
          
          // è®¡ç®—æ€»æ•°ç”¨äºç™¾åˆ†æ¯”
          const total = d3.sum(data, item => item.value)
          const percentage = Math.round((d.data.value / total) * 100)
          
          // åˆ›å»ºtooltip
          d3.select("body")
            .append("div")
            .attr("class", "pie-tooltip")
            .style("position", "absolute")
            .style("background", "rgba(0,0,0,0.9)")
            .style("color", "white")
            .style("padding", "10px")
            .style("border-radius", "6px")
            .style("font-size", "12px")
            .style("pointer-events", "none")
            .style("z-index", "9999")
            .style("box-shadow", "0 2px 8px rgba(0,0,0,0.3)")
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 10) + "px")
            .html(`
              <div style="font-weight: bold; margin-bottom: 4px;">${d.data.name}</div>
              <div>æ•°é‡: ${d.data.value} ä¸ª</div>
              <div>å æ¯”: ${percentage}%</div>
            `)
        })
        .on("mouseout", (event, d) => {
          // ç§»é™¤hoveræ•ˆæœ
          d3.select(event.currentTarget).style("opacity", 1)
          
          // ç§»é™¤tooltip
          d3.selectAll(".pie-tooltip").remove()
        })
      
      // æ·»åŠ ç™¾åˆ†æ¯”æ ‡ç­¾åœ¨æ‰‡å½¢å†…éƒ¨
      arcs.append("text")
        .attr("transform", d => `translate(${arc.centroid(d)})`)
        .attr("text-anchor", "middle")
        .attr("font-size", "11px")
        .attr("fill", "#fff")
        .attr("font-weight", "bold")
        .text(d => {
          const percentage = Math.round(d.data.value / d3.sum(data, d => d.value) * 100)
          return percentage > 5 ? `${percentage}%` : "" // åªæ˜¾ç¤ºå¤§äº5%çš„æ ‡ç­¾
        })
      
      // å°†å›¾ä¾‹æ”¾åœ¨å³ä¸Šè§’
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${radius + 15}, ${-radius})`) // æ”¾åœ¨é¥¼å›¾å³ä¸Šè§’
      
      const legendItems = legend.selectAll(".legend-item")
        .data(data)
        .enter()
        .append("g")
        .attr("class", "legend-item")
        .attr("transform", (d, i) => `translate(0, ${i * 15})`) // å‡å°‘è¡Œé—´è·
      
      // å›¾ä¾‹è‰²å—
      legendItems.append("rect")
        .attr("width", 15)
        .attr("height", 15)
        .attr("fill", d => d.color)
        .attr("rx", 3) // åœ†è§’
        .style("cursor", "pointer")
        .on("mouseover", (event, d) => {
          // ç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§tooltip
          d3.selectAll(".pie-tooltip").remove()
          
          // è®¡ç®—æ€»æ•°ç”¨äºç™¾åˆ†æ¯”
          const total = d3.sum(data, item => item.value)
          const percentage = Math.round((d.value / total) * 100)
          
          // åˆ›å»ºtooltip
          d3.select("body")
            .append("div")
            .attr("class", "pie-tooltip")
            .style("position", "absolute")
            .style("background", "rgba(0,0,0,0.9)")
            .style("color", "white")
            .style("padding", "10px")
            .style("border-radius", "6px")
            .style("font-size", "12px")
            .style("pointer-events", "none")
            .style("z-index", "9999")
            .style("box-shadow", "0 2px 8px rgba(0,0,0,0.3)")
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 10) + "px")
            .html(`
              <div style="font-weight: bold; margin-bottom: 4px;">${d.name}</div>
              <div>æ•°é‡: ${d.value} ä¸ª</div>
              <div>å æ¯”: ${percentage}%</div>
            `)
        })
        .on("mouseout", (event, d) => {
          // ç§»é™¤tooltip
          d3.selectAll(".pie-tooltip").remove()
        })
    },
    
    // æ›´æ–°é¥¼å›¾
    updatePieChart() {
      const container = this.$refs.pieContainer
      if (!container) return
      
      // é‡æ–°æ¸²æŸ“é¥¼å›¾
      this.renderPieChart()
    },
    
    // æ¸²æŸ“æ”¶æ•›æ€§å›¾è¡¨
    renderConvergenceChart() {
      const container = this.$refs.convergenceContainer
      if (!container) return
      
      d3.select(container).selectAll("*").remove()
      
      const containerWidth = container.clientWidth
      const containerHeight = 180
      
      const margin = { top: 20, right: 60, bottom: 40, left: 50 }
      const width = containerWidth - margin.left - margin.right
      const height = containerHeight - margin.top - margin.bottom
      
      const svg = d3.select(container)
        .append("svg")
        .attr("width", containerWidth)
        .attr("height", containerHeight)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
      
      // å¦‚æœæ²¡æœ‰æ”¶æ•›æ•°æ®ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
      if (this.convergenceData.length === 0) {
        svg.append("text")
          .attr("x", width / 2)
          .attr("y", height / 2)
          .attr("text-anchor", "middle")
          .attr("font-size", "14px")
          .text("è¿è¡Œæ¨¡æ‹Ÿä»¥æŸ¥çœ‹æ”¶æ•›æ€§åˆ†æ")
        return
      }
      
      // åˆ›å»ºæ¯”ä¾‹å°º
      const x = d3.scaleLinear()
        .domain([0, d3.max(this.convergenceData, d => d.iteration)])
        .range([0, width])
      
      // éš”ç¦»æŒ‡æ•°çš„æ¯”ä¾‹å°º (ä¸»è¦Yè½´)
      const yIndex = d3.scaleLinear()
        .domain([0, Math.max(100, d3.max(this.convergenceData, d => d.segregationIndex) * 1.1)])
        .range([height, 0])
      
      // æ”¶æ•›å¾—åˆ†çš„æ¯”ä¾‹å°º (æ¬¡è¦Yè½´)
      const yScore = d3.scaleLinear()
        .domain([0, 100])
        .range([height, 0])
      
      // åˆ›å»ºçº¿æ¡ç”Ÿæˆå™¨
      const indexLine = d3.line()
        .x(d => x(d.iteration))
        .y(d => yIndex(d.segregationIndex))
        .curve(d3.curveMonotoneX)
      
      const smoothedLine = d3.line()
        .x(d => x(d.iteration))
        .y(d => yIndex(d.smoothedIndex))
        .curve(d3.curveMonotoneX)
      
      const scoreLine = d3.line()
        .x(d => x(d.iteration))
        .y(d => yScore(d.overallScore))
        .curve(d3.curveMonotoneX)
      
      // æ·»åŠ åæ ‡è½´
      svg.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(x).ticks(5))
      
      svg.append("g")
        .attr("class", "y-axis-left")
        .call(d3.axisLeft(yIndex).ticks(5))
      
      svg.append("g")
        .attr("class", "y-axis-right")
        .attr("transform", `translate(${width}, 0)`)
        .call(d3.axisRight(yScore).ticks(5))
      
      // æ·»åŠ åæ ‡è½´æ ‡ç­¾
      svg.append("text")
        .attr("class", "x-label")
        .attr("x", width / 2)
        .attr("y", height + 35)
        .attr("text-anchor", "middle")
        .attr("font-size", "11px")
        .text("è¿­ä»£æ¬¡æ•°")
      
      svg.append("text")
        .attr("class", "y-label-left")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -35)
        .attr("text-anchor", "middle")
        .attr("font-size", "11px")
        .attr("fill", "#e74c3c")
        .text("éš”ç¦»æŒ‡æ•°")
      
      svg.append("text")
        .attr("class", "y-label-right")
        .attr("transform", "rotate(90)")
        .attr("x", height / 2)
        .attr("y", -width - 45)
        .attr("text-anchor", "middle")
        .attr("font-size", "11px")
        .attr("fill", "#3498db")
        .text("æ”¶æ•›å¾—åˆ† (%)")
      
      // æ·»åŠ ç½‘æ ¼çº¿
      svg.append("g")
        .attr("class", "grid")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(x)
          .tickSize(-height)
          .tickFormat("")
        )
        .style("stroke-dasharray", "2,2")
        .style("opacity", 0.3)
      
      svg.append("g")
        .attr("class", "grid")
        .call(d3.axisLeft(yIndex)
          .tickSize(-width)
          .tickFormat("")
        )
        .style("stroke-dasharray", "2,2")
        .style("opacity", 0.3)
      
      // ç»˜åˆ¶éš”ç¦»æŒ‡æ•°åŸå§‹æ›²çº¿
      svg.append("path")
        .datum(this.convergenceData)
        .attr("class", "index-line")
        .attr("fill", "none")
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-opacity", 0.7)
        .attr("d", indexLine)
      
      // ç»˜åˆ¶éš”ç¦»æŒ‡æ•°å¹³æ»‘æ›²çº¿
      svg.append("path")
        .datum(this.convergenceData)
        .attr("class", "smoothed-line")
        .attr("fill", "none")
        .attr("stroke", "#c0392b")
        .attr("stroke-width", 3)
        .attr("d", smoothedLine)
      
      // ç»˜åˆ¶æ”¶æ•›å¾—åˆ†æ›²çº¿
      svg.append("path")
        .datum(this.convergenceData)
        .attr("class", "score-line")
        .attr("fill", "none")
        .attr("stroke", "#3498db")
        .attr("stroke-width", 2)
        .attr("d", scoreLine)
      
      // æ·»åŠ æ”¶æ•›çŠ¶æ€æ ‡è®°ç‚¹
      const statusColors = {
        'converged': '#27ae60',
        'converging': '#f39c12',
        'oscillating': '#e67e22',
        'diverging': '#e74c3c'
      }
      
      svg.selectAll(".status-point")
        .data(this.convergenceData.filter((d, i) => i % 3 === 0)) // æ¯3ä¸ªç‚¹æ˜¾ç¤ºä¸€ä¸ªçŠ¶æ€
        .enter()
        .append("circle")
        .attr("class", "status-point")
        .attr("cx", d => x(d.iteration))
        .attr("cy", d => yIndex(d.segregationIndex))
        .attr("r", 4)
        .attr("fill", d => statusColors[d.status] || '#95a5a6')
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
      
      // æ·»åŠ é¢„æµ‹çº¿ (å¦‚æœæœ‰è¶³å¤Ÿæ•°æ®)
      if (this.convergenceData.length >= 10) {
        const lastPoint = this.convergenceData[this.convergenceData.length - 1]
        const predictedY = yIndex(lastPoint.predictedFinal)
        
        svg.append("line")
          .attr("class", "prediction-line")
          .attr("x1", x(lastPoint.iteration))
          .attr("y1", yIndex(lastPoint.segregationIndex))
          .attr("x2", width)
          .attr("y2", predictedY)
          .attr("stroke", "#9b59b6")
          .attr("stroke-width", 2)
          .attr("stroke-dasharray", "5,5")
          .attr("opacity", 0.7)
        
        // é¢„æµ‹å€¼æ ‡ç­¾
        svg.append("text")
          .attr("x", width - 5)
          .attr("y", predictedY - 5)
          .attr("text-anchor", "end")
          .attr("font-size", "10px")
          .attr("fill", "#9b59b6")
          .text(`é¢„æµ‹: ${lastPoint.predictedFinal.toFixed(1)}`)
      }
      
      // æ·»åŠ å›¾ä¾‹
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(10, 10)`)
      
      const legendItems = [
        { name: "éš”ç¦»æŒ‡æ•°", color: "#e74c3c", style: "solid" },
        { name: "å¹³æ»‘æ›²çº¿", color: "#c0392b", style: "solid" },
        { name: "æ”¶æ•›å¾—åˆ†", color: "#3498db", style: "solid" },
        { name: "é¢„æµ‹è¶‹åŠ¿", color: "#9b59b6", style: "dashed" }
      ]
      
      legendItems.forEach((item, i) => {
        const legendItem = legend.append("g")
          .attr("transform", `translate(0, ${i * 15})`)
        
        legendItem.append("line")
          .attr("x1", 0)
          .attr("y1", 5)
          .attr("x2", 15)
          .attr("y2", 5)
          .attr("stroke", item.color)
          .attr("stroke-width", 2)
          .attr("stroke-dasharray", item.style === "dashed" ? "3,3" : "0")
        
        legendItem.append("text")
          .attr("x", 20)
          .attr("y", 5)
          .attr("alignment-baseline", "middle")
          .attr("font-size", "9px")
          .text(item.name)
      })
    },
    
    // æ›´æ–°æ”¶æ•›æ€§å›¾è¡¨
    updateConvergenceChart() {
      // é‡æ–°æ¸²æŸ“æ”¶æ•›æ€§å›¾è¡¨
      this.renderConvergenceChart()
    }
  }
}
</script>
<style scoped>
.schelling-model {
  padding: 2rem;
  background-color: #f5f7fa;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.main-card {
  margin-bottom: 2rem;
  flex: 1;
  display: flex;
  flex-direction: column;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header h2 {
  margin: 0;
  color: #2c3e50;
}

.header p {
  margin: 0.5rem 0 0;
  color: #7f8c8d;
}

.grid-container {
  width: 100%;
  height: 100%; /* å›ºå®šåˆç†é«˜åº¦ï¼Œé¿å…è¶…å‡ºé¡µé¢ */
  max-height: 700px; /* å¢å¤§æœ€å¤§é«˜åº¦é™åˆ¶ */
  min-height: 400px; /* å¢å¤§æœ€å°é«˜åº¦ */
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: visible; /* ç¡®ä¿å†…å®¹å¯è§ */
  border: 1px solid #e1e8ed; /* æ·»åŠ è¾¹æ¡†ä¾¿äºè§‚å¯Ÿ */
  border-radius: 4px;
  background-color: #fafbfc; /* æµ…è‰²èƒŒæ™¯ */
}

.grid-flex-container {
  height: 100%; /* å›ºå®šåˆç†é«˜åº¦ */
  max-height: 750px; /* å¢å¤§æœ€å¤§é«˜åº¦é™åˆ¶ */
  width: 100%;
  min-height: 400px; /* å¢å¤§æœ€å°é«˜åº¦ */
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: visible; /* ç¡®ä¿å†…å®¹å¯è§ */
  padding: 5px; /* å‡å°‘å†…è¾¹è· */
}

.grid-card {
  height: 500px; /* å›ºå®šåˆç†é«˜åº¦ */
  max-height: 800px; /* å¢å¤§æœ€å¤§é«˜åº¦é™åˆ¶ */
}

.grid-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.grid-header h3 {
  margin: 0;
}

.color-legend {
  display: flex;
  gap: 1rem;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.color-box {
  width: 0.75rem;
  height: 0.75rem;
  border-radius: 0.125rem;
}

.grid-tabs :deep(.el-tabs__content) {
  overflow: visible;
  height: calc(100vh - 12.5rem);
}

/* ä»ªè¡¨ç›˜å¯¹è¯æ¡†æ ·å¼ */
.dashboard-dialog :deep(.el-dialog__body) {
  padding: 2rem;
}

.dashboard-card {
  height: 22rem; /* ç»Ÿä¸€æ‰€æœ‰ä»ªè¡¨å¡ç‰‡é«˜åº¦ */
}

.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.dashboard-header h3 {
  margin: 0;
  font-size: 1rem;
}

.gauge-container, .pie-container, .convergence-container {
  width: 100%;
  height: 18rem; /* ç»Ÿä¸€æ‰€æœ‰ä»ªè¡¨å®¹å™¨é«˜åº¦ */
  display: flex;
  justify-content: center;
  align-items: center;
}

.large-chart-container {
  width: 100%;
  height: 12.5rem;
}

/* ä¸»è¦å¸ƒå±€å®¹å™¨ - é’ˆå¯¹å·¦å³åˆ†æ å¸ƒå±€ */
.main-layout-container {
  display: flex;
  gap: 1.5rem;
  height: calc(100vh - 8rem);
}

/* å·¦ä¾§å‚æ•°é¢æ¿ - æ‰©å¤§å®½åº¦ */
.left-panel {
  flex: 0 0 25rem; /* å›ºå®šå®½åº¦400pxï¼Œç¡®ä¿å‚æ•°å®Œå…¨æ˜¾ç¤º */
  min-width: 25rem;
  max-width: 28rem;
}

/* å³ä¾§å†…å®¹åŒºåŸŸ */
.right-panel {
  flex: 1;
  min-width: 0; /* ç¡®ä¿flexé¡¹ç›®å¯ä»¥ç¼©å° */
}

/* æ·»åŠ åŠ¨ç”»æ•ˆæœ */
.gauge-pointer {
  transition: transform 0.5s ease-out;
}

.gauge-foreground {
  transition: d 0.5s ease-out;
}

.gauge-value {
  transition: all 0.5s ease-out;
}

/* è¶…å¤§å±å¹•ä¼˜åŒ– */
@media (min-width: 100rem) { /* 1600px+ */
  .schelling-model {
    padding: 3rem;
  }
  
  .left-panel {
    flex: 0 0 30rem; /* æ›´å¤§å±å¹•å¯ä»¥ç»™æ›´å¤šç©ºé—´ */
    min-width: 30rem;
    max-width: 35rem;
  }
  
  .grid-container {
    max-height: 900px; /* å¤§å±å¹•å…è®¸æ›´å¤§é«˜åº¦ */
    min-height: 500px;
  }
  
  .grid-flex-container {
    max-height: 950px;
    min-height: 500px;
  }
  
  .grid-card {
    height: 600px;
    max-height: 1000px;
  }
  
  .dashboard-card {
    height: 24rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 20rem;
  }
  
  .large-chart-container {
    height: 15rem;
  }
}

/* å¤§å±å¹• (1200px+) */
@media (max-width: 75rem) and (min-width: 64rem) { /* 1200px - 1024px */
  .schelling-model {
    padding: 1.5rem;
  }
  
  .main-layout-container {
    gap: 1.25rem;
  }
  
  .left-panel {
    flex: 0 0 24rem; /* 1200pxå±å¹•ä¿æŒè¾ƒå¤§å®½åº¦ */
    min-width: 24rem;
    max-width: 26rem;
  }
  
  .grid-container {
    max-height: 800px; /* ä¸­å¤§å±å¹•é€‚å½“å¢å¤§ */
    min-height: 450px;
  }
  
  .grid-flex-container {
    max-height: 850px;
    min-height: 450px;
  }
  
  .grid-card {
    height: 550px;
    max-height: 900px;
  }
  
  .dashboard-card {
    height: 20rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 16rem;
  }
  
  .large-chart-container {
    height: 11rem;
  }
}

/* 1Kåˆ†è¾¨ç‡ä¼˜åŒ– (1024px) */
@media (max-width: 64rem) and (min-width: 58rem) { /* 1024px - 928px */
  .schelling-model {
    padding: 1.25rem;
  }
  
  .main-layout-container {
    gap: 1rem;
    height: calc(100vh - 7rem);
  }
  
  .left-panel {
    flex: 0 0 22rem; /* 1Kå±å¹•ç¡®ä¿å‚æ•°é¢æ¿è¶³å¤Ÿå®½ */
    min-width: 22rem;
    max-width: 24rem;
  }
  
  .dashboard-card {
    height: 19rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 15rem;
  }
  
  .large-chart-container {
    height: 10.5rem;
  }
}

/* ä¸­ç­‰å±å¹• (992px) */
@media (max-width: 58rem) and (min-width: 48rem) { /* 928px - 768px */
  .schelling-model {
    padding: 1rem;
  }
  
  .main-layout-container {
    gap: 0.75rem;
    height: calc(100vh - 6rem);
  }
  
  .left-panel {
    flex: 0 0 20rem; /* ä¸­ç­‰å±å¹•é€‚å½“å‡å°‘ä½†ä¿æŒè¶³å¤Ÿå®½åº¦ */
    min-width: 20rem;
    max-width: 22rem;
  }
  
  .main-card {
    margin-bottom: 1.5rem;
  }
  
  .dashboard-card {
    height: 18rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 14rem;
  }
  
  .large-chart-container {
    height: 10rem;
  }
  
  .color-legend {
    gap: 0.75rem;
  }
  
  .legend-item {
    gap: 0.375rem;
  }
}

/* å¹³æ¿ç«–å± (768px) */
@media (max-width: 48rem) { /* 768px */
  .schelling-model {
    padding: 0.75rem;
  }
  
  /* åœ¨å¹³æ¿ä¸Šæ”¹ä¸ºå‚ç›´å¸ƒå±€ */
  .main-layout-container {
    flex-direction: column;
    gap: 1rem;
    height: auto;
  }
  
  .left-panel {
    flex: none;
    width: 100%;
    min-width: auto;
    max-width: none;
  }
  
  .right-panel {
    flex: none;
  }
  
  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .grid-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .color-legend {
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  
  .dashboard-card {
    height: 15rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 12rem;
  }
  
  .large-chart-container {
    height: 9rem;
  }
  
  .grid-flex-container {
    height: calc(100vh - 15rem);
  }
  
  .grid-card {
    height: calc(100vh - 12rem);
  }
}

/* æ‰‹æœºæ¨ªå±/å°å¹³æ¿ (576px) */
@media (max-width: 36rem) { /* 576px */
  .schelling-model {
    padding: 0.5rem;
  }
  
  .main-card {
    margin-bottom: 1rem;
  }
  
  .main-layout-container {
    gap: 0.75rem;
  }
  
  .dashboard-card {
    height: 13rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 10rem;
  }
  
  .large-chart-container {
    height: 8rem;
  }
  
  .dashboard-header h3 {
    font-size: 0.875rem;
  }
  
  .color-box {
    width: 0.625rem;
    height: 0.625rem;
  }
  
  .grid-flex-container {
    height: calc(100vh - 18rem);
  }
  
  .grid-card {
    height: calc(100vh - 15rem);
  }
}

/* å°æ‰‹æœº (384px) */
@media (max-width: 24rem) { /* 384px */
  .schelling-model {
    padding: 0.25rem;
  }
  
  .main-layout-container {
    gap: 0.5rem;
  }
  
  .dashboard-card {
    height: 12rem;
  }
  
  .gauge-container, .pie-container, .convergence-container {
    height: 9rem;
  }
  
  .large-chart-container {
    height: 7rem;
  }
  
  .color-legend {
    gap: 0.25rem;
  }
  
  .legend-item {
    gap: 0.25rem;
    font-size: 0.875rem;
  }
}

/* å‚æ•°é¢æ¿å†…éƒ¨ä¼˜åŒ– */
.parameter-panel {
  padding: 1.5rem;
  background: white;
  border-radius: 0.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  height: 100%;
  overflow-y: auto;
}

.parameter-section {
  margin-bottom: 1.5rem;
}

.parameter-section:last-child {
  margin-bottom: 0;
}

.parameter-title {
  font-size: 1.1rem;
  font-weight: 600;
  color: #2c3e50;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #e1e8ed;
}

.parameter-item {
  margin-bottom: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.parameter-label {
  font-weight: 500;
  color: #34495e;
  font-size: 0.95rem;
}

.parameter-description {
  font-size: 0.85rem;
  color: #7f8c8d;
  line-height: 1.4;
}

/* æ§åˆ¶æŒ‰é’®ç»„ä¼˜åŒ– */
.control-buttons {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid #e1e8ed;
}

.control-row {
  display: flex;
  gap: 0.5rem;
}

.control-row .el-button {
  flex: 1;
}

/* é«˜äº®åŠ¨ç”» */
@keyframes pulse {
  0% { opacity: 0.7; }
  50% { opacity: 1; }
  100% { opacity: 0.7; }
}

.cell:hover rect {
  stroke: #34495e;
  stroke-width: 0.125rem;
}

/* ä»‹ç»å¼¹çª—æ ·å¼ */
.intro-content h3 {
  color: #2c3e50;
  margin-top: 1.25rem;
  margin-bottom: 0.625rem;
}

.intro-content p {
  color: #34495e;
  line-height: 1.6;
}

.intro-content ul {
  padding-left: 1.25rem;
}

.intro-content li {
  margin-bottom: 0.5rem;
  color: #34495e;
  line-height: 1.6;
}

/* ç¡®ä¿åœ¨1Kåˆ†è¾¨ç‡ä¸‹æ»šåŠ¨æ¡æ ·å¼ä¼˜åŒ– */
.parameter-panel::-webkit-scrollbar {
  width: 6px;
}

.parameter-panel::-webkit-scrollbar-track {
  background: #f1f3f4;
  border-radius: 3px;
}

.parameter-panel::-webkit-scrollbar-thumb {
  background: #c1c8cd;
  border-radius: 3px;
}

.parameter-panel::-webkit-scrollbar-thumb:hover {
  background: #a8b2b9;
}
</style>